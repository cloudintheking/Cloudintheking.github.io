{"meta":{"title":"cloudintheking","subtitle":"时光醉清风,总有人会记得","description":"北落师门","author":"cloudintheking","url":"https://cloudintheking.github.io","root":"/"},"pages":[{"title":"开源项目","date":"2018-09-08T02:09:11.000Z","updated":"2021-04-26T14:32:43.731Z","comments":false,"path":"works/index.html","permalink":"https://cloudintheking.github.io/works/index.html","excerpt":"","text":"jt809-netty：全国道路运输车辆定位通讯协议jt809-2011实现miniTemplate：微信小程序原生框架myportal：动态门户网站myportal_server：动态门户接口myutils：自定义excel、二维码工具库"},{"title":"categories","date":"2018-07-28T14:16:29.000Z","updated":"2021-04-25T15:44:16.049Z","comments":false,"path":"categories/index.html","permalink":"https://cloudintheking.github.io/categories/index.html","excerpt":"","text":""},{"title":"画集","date":"2018-09-07T15:16:52.000Z","updated":"2021-04-26T14:32:52.282Z","comments":false,"path":"paint/index.html","permalink":"https://cloudintheking.github.io/paint/index.html","excerpt":"","text":"吾友猪猪🐷与吾🐵的画集🎨"},{"title":"tags","date":"2018-07-28T14:12:09.000Z","updated":"2021-04-25T15:44:16.049Z","comments":false,"path":"tags/index.html","permalink":"https://cloudintheking.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"powershell之启动远程jar服务","slug":"powershell之启动远程jar服务","date":"2022-01-05T05:20:45.000Z","updated":"2022-01-05T05:21:21.167Z","comments":true,"path":"posts/3edeb9a.html","link":"","permalink":"https://cloudintheking.github.io/posts/3edeb9a.html","excerpt":"","text":"- - 个人笔记，如有描述不当，欢迎留言指出~ 起因主管抽风说每次都要登录远程服务器再启动jar太麻烦了，要是有个一键启动远程jar的批处理就是。于是这个任务就交给我了… powershell配置用管理员权限启动 PowerShell,执行下面的命令:123456789101112131415161718#客户端或服务器公共配置:Get-Service WinRM #查看WinRM服务的状态Enable-PSRemoting –Force #配置系统接受远程命令Set-Service WinRM -StartMode Automatic #开启WinRM服务自启动winrm set winrm/config/winrs '@&#123;MaxMemoryPerShellMB=\"3000\"&#125;' #设置powershell最大内存 方法一推荐Set-Item WSMan:\\localhost\\Plugin\\Microsoft.PowerShell\\Quotas\\MaxMemoryPerShellMB 3000 #设置最大内存 方法二Restart-Service winrm //重启winrm服务使配置生效#服务器配置:Set-Item WSMan:localhost\\client\\trustedhosts -value \"192.168.1.44,192.168.1.45\" #设置设置主机可信任的客户端地址winrm set winrm/config/client @&#123;TrustedHosts=\"192.168.1.45,192.168.1.44\"&#125; #设置设置主机可信任的客户端地址，当上个命令无效时，可选用该命令（该命令请在cmd中使用） Get-Item WSMan:\\localhost\\Client\\TrustedHosts #查看可信任主机get-executionpolicy #查看脚本执行策略set-executionpolicy remotesigned #设置执行策略为远程可执行Restart-Service winrm #重启服务生效Test-WsMan xxx.xxx.xxx.xxx #客户端测试远程连接 jar包上传处理命令 服务器上必须安装了ftp,否则没法上传文件。我公司服务器系统是windows server 2008,用它自带的IIS创建ftp,并设置虚拟目录。 新建上传文件脚本up.bat：123456789101112131415161718curl -X POST 192.168.1.44:8886/shutdown #关闭44服务器上8886端口服务curl -X POST 192.168.1.44:8887/shutdown#关闭44服务器上8887端口服务curl -X POST 192.168.1.44:8888/shutdown#关闭44服务器上8888端口服务Echo open 192.168.1.44 &gt;ftp.up #打开连接44服务器ftp连接Echo Administrator&gt;&gt;ftp.up #服务器上登录用户名Echo 59@SDS25&gt;&gt;ftp.up #登录密码Echo cd .\\project1&gt;&gt;ftp.up #因为进入的是ftp的根目录，所以使用.\\project1,进入根目录下的project1Echo binary&gt;&gt;ftp.up #二进制数据传输格式Echo put \"E:\\Workspace\\idea\\jcnyJava\\target\\jcny-java-0.0.1-SNAPSHOT.jar\"&gt;&gt;ftp.up #传送本地文件到ftp中Echo cd ..\\project2&gt;&gt;ftp.up #使用..\\project2,进入根目录下的project2目录Echo put \"E:\\Workspace\\idea\\jcnyJava\\target\\jcny-java-0.0.1-SNAPSHOT.jar.original\"&gt;&gt;ftp.up #传送本地文件到ftp中Echo cd ..\\project3&gt;&gt;ftp.up #进入根目录下的project3目录Echo put \"E:\\Workspace\\idea\\jcnyJava\\target\\jcny-java-0.0.1-SNAPSHOT.jar.original\"&gt;&gt;ftp.up #传送本地文件到ftp中Echo bye&gt;&gt;ftp.up #客户端关闭ftp连接FTP -s:ftp.up #服务器关闭ftp连接del ftp.up /q #删除ftp连接Pause powershell启动远程服务命令新建一个启动脚本deploy.ps112345678$na = \"yourname\" #服务器用户名 $p2 = ConvertTo-SecureString \"yourpassword\" -AsPlainText -Force #加密登录密码 $A = New-Object System.Management.Automation.PSCredential($na,$p2) #创建连接Invoke-Command -ComputerName 192.168.1.44 -Credential $A -ScriptBlock &#123; #执行远程操作Set-Location E:\\webroot\\projects #进入远程服务器目录invoke-expression -command E:\\webroot\\tongtu-projects\\startall.bat #远程服务启动的脚本路径&#125; 以上命令都是针对Windows系统的，Linux系统应该是写bash脚本吧。如果下次主管说要一键启动远程Linux上的服务的话，到时候我再写篇linux的吧。","categories":[],"tags":[]},{"title":"mongodb操作之$slice","slug":"mongodb操作之-slice","date":"2022-01-05T05:14:55.000Z","updated":"2022-01-05T05:22:00.194Z","comments":true,"path":"posts/9885f22a.html","link":"","permalink":"https://cloudintheking.github.io/posts/9885f22a.html","excerpt":"","text":"- - 个人笔记，如有描述不当，欢迎留言指出~ 翻译原文：https://docs.mongodb.com/manual/reference/operator/update/slice/#examples $slice（切分）当进行$push(插入)操作时，可以通过 $slice修饰词来限制插入的数组元素个数。如果想从一个只读操作中映射或是返回数组元素中特定的值，详见$slice映射操作。$slice修饰词必须搭配$each修饰词才能使用。不过，你也可以传递一个空数组给$each修饰词，从而只让$slice修饰词起作用。12345678&#123; $push: &#123; &lt;field&gt;: &#123; $each: [ &lt;value1&gt;, &lt;value2&gt;, ... ], $slice: &lt;num&gt; &#125; &#125;&#125; &lt; num &gt; 的值可以是： Value Description 0 更新数组&lt;field&gt;为空数组 负数 更新数组&lt;field&gt;只包含最后&lt;num&gt;个元素 正数 更新数组&lt;field&gt;只包含开头&lt;num&gt;个元素，适用于2.6以上版本 Behavior(行为)这些修饰词出现的顺序是无关紧要的。不过在上一个版本中，要求$each修饰词得作为第一个修饰词出现，如果要和$slice修饰词连用的话。这里有一份关于和$push搭配使用的修饰词列表，详见Modifiers。不结合$each修饰词而只使用$slice修饰词将会导致出错，不信可以试试。 栗子从数组末尾切片一个学生集合包含以下文档：1&#123; \"_id\" : 1, \"scores\" : [ 40, 50, 60 ] &#125; 下面的操作增加一个新元素到scores数组中，然后使用$slice将数组修剪为最后五个元素。 1234567891011db.students.update( &#123; _id: 1 &#125;, &#123; $push: &#123; scores: &#123; $each: [ 80, 78, 86 ], $slice: -5 &#125; &#125; &#125;) 操作的结果就是将更新后的scores数组切分为最后5个元素1&#123; \"_id\" : 1, \"scores\" : [ 50, 60, 80, 78, 86 ] &#125; 从数组头部切片一个学生集合包含以下文档：1&#123; \"_id\" : 2, \"scores\" : [ 89, 90 ] &#125; 下面的操作增加一个新元素到scores数组中，然后使用$slice修饰词修剪为前三个元素。1234567891011db.students.update( &#123; _id: 2 &#125;, &#123; $push: &#123; scores: &#123; $each: [ 100, 20 ], $slice: 3 &#125; &#125; &#125;) 操作的结果就是将更新后的scores数组切分为前三个元素中。 只用slice来更新数组一个学生集合包含以下文档：1&#123; \"_id\" : 3, \"scores\" : [ 89, 70, 100, 20 ] &#125; 为了只用$slice修饰词来更新scores字段，我们得给出要切分的元素数量（比如 -3）赋给slice修饰词,而且赋一个空数组给$each修饰词，就像下面的代码：1234567891011db.students.update( &#123; _id: 3 &#125;, &#123; $push: &#123; scores: &#123; $each: [ ], $slice: -3 &#125; &#125; &#125;) 操作的结果就是将scores数组切分为最后三个元素。 slice 和push搭配使用一个学生集合包含以下文档：123456789&#123; \"_id\" : 5, \"quizzes\" : [ &#123; \"wk\": 1, \"score\" : 10 &#125;, &#123; \"wk\": 2, \"score\" : 8 &#125;, &#123; \"wk\": 3, \"score\" : 5 &#125;, &#123; \"wk\": 4, \"score\" : 6 &#125; ]&#125; 下面的$push操作将会： 使用$each修饰词来增加多个文档到quizzes数组中， 使用$sort修饰词，按照score字段来降序排序修改过的quizzies数组中的全部元素， 使用$slice修饰词，只保留quizzes数排中前三个排序过的元素。 123456789101112db.students.update( &#123; _id: 5 &#125;, &#123; $push: &#123; quizzes: &#123; $each: [ &#123; wk: 5, score: 8 &#125;, &#123; wk: 6, score: 7 &#125;, &#123; wk: 7, score: 6 &#125; ], $sort: &#123; score: -1 &#125;, $slice: 3 &#125; &#125; &#125;) 操作结果就是只保留了quizzes数组中分数最高的三个元素。12345678&#123; \"_id\" : 5, \"quizzes\" : [ &#123; \"wk\" : 1, \"score\" : 10 &#125;, &#123; \"wk\" : 2, \"score\" : 8 &#125;, &#123; \"wk\" : 5, \"score\" : 8 &#125; ]&#125; 上面操作中的修饰词都会被Mongodb自行处理，所有它们之间的书写顺序无关紧要。更多详情请见Modifiers。","categories":[],"tags":[]},{"title":"jhipster学习记录之jdl","slug":"jhipster学习记录之jdl","date":"2022-01-05T05:13:39.000Z","updated":"2022-01-05T05:14:16.657Z","comments":true,"path":"posts/879ad6bc.html","link":"","permalink":"https://cloudintheking.github.io/posts/879ad6bc.html","excerpt":"","text":"- - 个人笔记，如有描述不当，欢迎留言指出~ jhipster学习记录之jdl环境 os：windows10 java：1.8.0_161 node：10.16.0 npm：6.9.0 jhipster：6.1.0 jhipster学习jhipster最好的方式，当然是去看官网啦,而且英语不好的小伙伴可以去官方维护的中文站点👉here 官网的入门指南里告诉我们，在命令行中敲下入hipster，随后就是一系列的选择配置，最终等待jhipster生成代码。 但有没有觉得这样很low阿，它有这几个缺点： 每次新建项目，都有进行大量的配置选择，效率低 每次都只能生成一个项目，对于微服务项目，服务模块都要输入jhipster生成，效率低 所以我耐着性子继续往下看，当看到jdl的时候，发现上面两个缺点就不存在了 jdl（jhipster doman language）jhipster领域驱动语言，详见👉here只要编写一次jdl文件，就可以到处运行，再也没有烦人的配置选择了🙄1jhipster import-jdl \"your jdl file\" 它的语法其实挺简单，而且5.0以后支持注解，在定义的entity上直接使用@service、@dto、@paginate来代替service、dto、paginate 下面简单介绍一下jhipster生成代码流程：当在command中敲入jhipster，在一系列配置选择完后，jhipster会在根目录下生成.yo-rc.json文件和 .jhipster目录。 .yo-rc.json里存放应用的配置，对应jdl的application.config .*jhipster目录下存放应用的实体类配置，对应jdl中application.entites 、entity jhipster再根据这些文件去生成项目代码。如果你需要重建一个相同配置jhipster项目的话，直接拷贝.yo-rc.json文件和 .jhipster目录放到新建文件夹下，进入command，敲下jhipster,就会生成一个相同配置的项目 另外，jhipster一开始是支持前端框架angular的，后来慢慢加入了react和vue。但vue却并不在默认的选择配置中，如果你用过jhipster命令就会知道，在进行clentframework选项时，只会出现angular和react。如果前端如果要使用vue的话，就只能用jhipster提供的blueprint(蓝图)功能12npm install -g generator-jhipster-vuejsjhipster --blueprint vuejs 这样就可以生成一个前端框架是vue的项目。那么如何在jdl里应用呢？这里吐槽一下，官网里jdl的语法介绍的并不全，找了半天也没看到blueprint的语法！后来断点调试jhipster-core中，发现your node_modules folder\\node_modules\\generator-jhipster\\node_modules\\jhipster-core\\lib\\core\\jhipster\\application_options.js这个文件里存放了应用的所有配置参数 在你的j’d’l文件里加入下面的代码就可以啦1234567application &#123; config&#123; ... blueprint vuejs ... &#125;&#125; 此处奉上我练习写的jdl文件👉demo👈","categories":[],"tags":[]},{"title":"windows下编译mysql5.7.25","slug":"windows下编译mysql5-7-25","date":"2022-01-05T03:19:28.000Z","updated":"2022-01-05T05:27:14.598Z","comments":true,"path":"posts/511a3199.html","link":"","permalink":"https://cloudintheking.github.io/posts/511a3199.html","excerpt":"","text":"- - 个人笔记，如有描述不当，欢迎留言指出~ 环境 windows10 cmake3.14.4 perl bison2.4.1 boost1.59.0PS: 注意安装bison时,不要选择创建菜单、快捷键,否则在编译mysql时跟我一样掉进坑里,后面会说明下载源码mysql官网解压后目录： 使用cmake生成vs解决方案打开cmake-gui.exe填好目录后正常情况下会报下面的错误cmake检测不到boost的位置 找到WITH_BOOST参数，输入本地安装的boost目录，再次点击configure,等待配置完成,最后点击generate,等待初始化完成。打开开始build目录可以看到，cmake给我们生成了MySQL.sln解决方案 vs2019编译mysqlvs2019打开MySQL.sln后，可以看到一共生成了128个方案，全部编译非常耗时，所以我先只编译mysqld 如果你是跟着我的步骤一步步做下来，那你会得到下面的错误 一共105个错误，总结一下就两种错误 没有lex_hash.h文件 sql_locale.cc文件格式有问题,有乱码 先解决第二种，根据提示进入报错文件打开sql_locale.cc，好多乱码找到文件位置，重新保存为utf-8格式 第一种问题,我之前没搞懂出错原因，就用笨办法手动生成缺失文件，这里就不说了这种解决思路了，太笨后来偶然在网上发现一篇文章经过一番摸索,我才发现,虽然bison安装的路径里没有空格没有中文,可是bison加入了开始菜单,导致bison找不到m4.exe,进而无法生成lex_hash.h文件我也懒得重装bison,直接把m4.exe复制到编译后的sql目录下,然后重新编译下 调试mysqld初始化数据文件随便创建data目录，比如E:\\Downloads\\mysql\\data然后找到编译后的mysqld.exe文件，我这里是进入cmd模式输入初始文件命令1E:\\Downloads\\mysql\\build\\sql\\Debug&gt;mysqld.exe --initialize-insecure --datadir=E:\\Downloads\\mysql\\data 断言错误，根据提示来到mysqld.cc第4406行把DBUG_ASSERT(0)改成DBUG_ASSERT(1)重新编译一遍，重复执行再次打开data目录,已经生成相应文件 下面开始调试mysqld右键-&gt;属性命令参数中写上mysql的配置文件路径my.ini123456789101112131415161718192021[mysqld]port=3307#basedir=D:\\Environment\\mysql-8.0.16-winx64 datadir=E:\\Downloads\\mysql\\datamax_connections=200max_connect_errors=10character-set-server=utf8default-storage-engine=INNODBexplicit_defaults_for_timestamp=true#default_authentication_plugin=mysql_native_password[mysql]default-character-set=utf8 入口函数上打个断点 右键-&gt;调试-&gt;进入并单步执行新实例已经进入断点了,接下来慢慢探索吧…","categories":[],"tags":[]},{"title":"spring日记","slug":"spring日记","date":"2020-06-12T04:39:41.000Z","updated":"2021-04-26T13:07:09.998Z","comments":true,"path":"posts/dab52c7b.html","link":"","permalink":"https://cloudintheking.github.io/posts/dab52c7b.html","excerpt":"","text":"- - 个人笔记，如有描述不当，欢迎留言指出~ spring 日记Bean@Scope(作用域注解)关键属性： scopeName：作用域名，”prototype”、”singleton”、”request”、”session” proxyMode：代理模式，ScopedProxyMode. DEFAULT（默认为NO）、ScopedProxyMode.NO（不代理）、ScopedProxyMode.INTERFACES（基于jdk接口代理）、ScopedProxyMode.TARGET_CLASS（基于cglib代理） 用法：123@Component@Scope(scopeName=\"xx\",proxyMode=xxx)public class XXX&#123;&#125; 或者12345678@Configurationpublic class XXXConfig&#123; @Bean @Scope(scopeName=\"xx\",proxyMode=xxx) public Xxx getXxx()&#123; return new Xxx(); &#125;&#125; NOTE:若scopeName=”prototype”,proxyMode=ScopedProxyMode.NO,那每次都会得到一个新的bean;若scopeName=”prototype”,proxyMode=ScopedProxyMode.INTERFACES或TARGET_CLASS, 那么会被注入一个代理类（它是单例并非原型），代理类里根据scopeName来返回具体的bean。 缓存cacheManagercacheManager(缓存管理器)可以注册多个，但是id必须不同，另外必须指定其中一个cacheManager上加上@Primary，否则CacheAspectSupport(cache切面类)中获取cacheManager bean时返回多个会报错。 也可以不指定@Primary，但要注册一个cache配置类继承CachingConfigurerSupport,并覆盖其中cacheManager()方法，返回一个已注册的cacheManager @Cacheable中可以指定cacheManager, 故可以实现不同的缓存方式 EhcacheCacheManage、JcacheCacheManager、RedisCacheManager三者都继承了 AbstractTransactionSupportingCacheManager， 通过设置setTransactionAware(boolean transactionAware)方法，可以实现事务提交后再进行缓存操作（注意，不管事务最后成功与否，缓存都会执行，慎用！！） redisTemplateredisTemplate（redis缓存模板）中 setEnableTransactionSupport(boolean enableTransactionSupport)设置开启事务支持，结合@Transactional可以实现缓存回滚 other若一个方法上同时存在@Cacheable和@Transaction,spring默认cache代理优先级高于transaction,所以会出现先进行cache操作再进行transaction操作的情况。可以通过设置@EnableCaching(order=xxx)、@EnableTransactionManagement(order=xxx)中order值来调节代理顺序,order越小优先级越高。 事务@TransactionalEventListener事务事件监听器，一般用于事务提交成功时处理一些业务逻辑关键属性phase: TransactionPhase.BEFORE_COMMIT 事务提交前触发 TransactionPhase.AFTER_COMMIT 事务提交成功时触发 TransactionPhase.AFTER_ROLLBACK 事务回滚时触发 TransactionPhase.AFTER_COMPLETION 事务完成(事务提交成功后或回滚后触发)用法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyAfterTransactionEvent extends ApplicationEvent &#123; //自定义一些属性 //... public MyAfterTransactionEvent(Object... source) &#123; super(source); &#125;&#125;@Slf4j@Componentpublic class MyTransactionListener &#123; //注入一些bean //... @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) public void onHelloEvent(/** 自定义事件**/MyAfterTransactionEvent event) &#123; //提交后的业务逻辑 ... &#125; /** * 作用同上 **/@EventListener void onSaveUserEvent(MyAfterTransactionEvent event) &#123; TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() &#123; @Override public void afterCommit() &#123; //提交后的业务逻辑 //... &#125; &#125;); &#125; &#125;@Service public class HelloServiceImpl&#123; @Autowired private ApplicationEventPublisher publisher; @Transactional void test()&#123; //db操作 //... publisher.publishEvent(new MyAfterTransactionEvent()); &#125; &#125; NOTE: spring事件机制默认是同步的，使用 @TransactionalEventListener不过是异步调用，本质上监听方法的执行和事务是在同一线程中。而上面例子中我们的监听方法在事务提交成功时执行，千万不要在监听方法进行insert/update/delete操作，因为spring的事务是绑定线程的,事务虽然提交了，但仍和当前线程绑定，此时进行增删改操作都是无效的！！详见这篇外文怎么解决这个问题？目前能想到2种 1：在监听方法里调用异步方法来避免 2：在监听方法上添加@Transactional(propagation = Propagation.REQUIRES_NEW)，这样监听方法会创建新的事务 有的人可能会想在监听方法上加@Async，这样监听方法在子线程种执行，子线程不和主线程共享事务，从而解决上述问题。我只能说想法很美好，现实很骨感。前面说了spring的事务是绑定线程的， @TransactionalEventListener是监听当前线程的事务，而子线程中丢失了主线程的任务，结果就是你的监听器不起效 security我们知道SecurityContextHolder 持有security的contextSecurityContextHolder部分源码：123456789101112131415161718192021222324252627282930313233343536373839404142public class SecurityContextHolder &#123; public static final String MODE_THREADLOCAL = \"MODE_THREADLOCAL\"; //线程副本策略 public static final String MODE_INHERITABLETHREADLOCAL = \"MODE_INHERITABLETHREADLOCAL\";//可继承线程副本策略 public static final String MODE_GLOBAL = \"MODE_GLOBAL\"; //全局策略 public static final String SYSTEM_PROPERTY = \"spring.security.strategy\"; private static String strategyName = System.getProperty(SYSTEM_PROPERTY); private static SecurityContextHolderStrategy strategy; private static int initializeCount = 0; static &#123; initialize();&#125;private static void initialize() &#123; if (!StringUtils.hasText(strategyName)) &#123; // Set default 如果系统变量读不到，则默认为线程副本策略 strategyName = MODE_THREADLOCAL; &#125; if (strategyName.equals(MODE_THREADLOCAL)) &#123; strategy = new ThreadLocalSecurityContextHolderStrategy(); &#125; else if (strategyName.equals(MODE_INHERITABLETHREADLOCAL)) &#123; strategy = new InheritableThreadLocalSecurityContextHolderStrategy(); &#125; else if (strategyName.equals(MODE_GLOBAL)) &#123; strategy = new GlobalSecurityContextHolderStrategy(); &#125; else &#123; // Try to load a custom strategy 如果都不匹配，那么加载自定义策略，strategyName为自定义策略的类路径，自定义策略需实现SecurityContextHolderStrategy接口 try &#123; Class&lt;?&gt; clazz = Class.forName(strategyName); Constructor&lt;?&gt; customStrategy = clazz.getConstructor(); strategy = (SecurityContextHolderStrategy) customStrategy.newInstance(); &#125; catch (Exception ex) &#123; ReflectionUtils.handleReflectionException(ex); &#125; &#125; initializeCount++;&#125;... 从源码里可以看出,SecurityContextHolder 默认为线程副本策略，这就会导致异步线程中获取不到security的context,解决方法有4种： 1：配置文件中设置 spring.security.strategy=MODE_INHERITABLETHREADLOCAL 2：使用DelegatingSecurityContextRunnable.create(Runnable delegate, SecurityContext securityContext)装饰任务，或者使用DelegatingSecurityContextExecutor创建excutor(线程执行器) 3：和2的方法很像 ,excutor中设置任务装饰器 12345678910111213141516171819202122232425262728/** * security 异步任务装饰器 */static class ContextCopyingDecorator implements TaskDecorator &#123; @NonNull @Override public Runnable decorate(@NonNull Runnable runnable) &#123; RequestAttributes context = RequestContextHolder.currentRequestAttributes(); SecurityContext securityContext = SecurityContextHolder.getContext(); return () -&gt; &#123; try &#123; RequestContextHolder.setRequestAttributes(context); SecurityContextHolder.setContext(securityContext); runnable.run(); &#125; finally &#123; SecurityContextHolder.clearContext(); RequestContextHolder.resetRequestAttributes(); &#125; &#125;; &#125;&#125;@Beanpublic Executor createExecutor()&#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setTaskDecorator(new ContextCopyingDecorator()); ...&#125; 4：使用spring提供的MethodInvokingFactoryBean修改SecurityContextHolder策略 12345678 @Bean public MethodInvokingFactoryBean setSecurityStrategy() &#123; MethodInvokingFactoryBean factoryBean = new MethodInvokingFactoryBean(); factoryBean.setTargetClass(SecurityContextHolder.class); factoryBean.setStaticMethod(\"setStrategyName\"); factoryBean.setArguments(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL); return factoryBean;&#125; 扩展： 从SecurityContextHolder部分源码中不难看出，SecurityContextHolder在初始化时匹配3种策略名从而生成对应策略，若都没有匹配上，则加载自定义策略，此时strategyName（策略名）为自定义策略的类路径，自定义策略需实现SecurityContextHolderStrategy接口 自定义用户认证代码实现：1234567891011121314151617181920 //从spring容器中获取UserDetailsService(这个从数据库根据用户名查询用户信息,及加载权限的service)UserDetailsService userDetailsService = (UserDetailsService)SpringContextUtil.getBean(\"userDetailsService\"); //根据用户名username加载userDetailsUserDetails userDetails = userDetailsService.loadUserByUsername(username); //根据userDetails构建新的Authentication,这里使用了//PreAuthenticatedAuthenticationToken当然可以用其他token,如UsernamePasswordAuthenticationToken PreAuthenticatedAuthenticationToken authentication = new PreAuthenticatedAuthenticationToken(userDetails, userDetails.getPassword(),userDetails.getAuthorities()); //设置authentication中detailsauthentication.setDetails(new WebAuthenticationDetails(request)); //存放authentication到SecurityContextHolderSecurityContextHolder.getContext().setAuthentication(authentication);HttpSession session = request.getSession(true);//在session中存放security context,方便同一个session中控制用户的其他操作session.setAttribute(\"SPRING_SECURITY_CONTEXT\", SecurityContextHolder.getContext());","categories":[{"name":"后端笔记","slug":"后端笔记","permalink":"https://cloudintheking.github.io/categories/后端笔记/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://cloudintheking.github.io/tags/spring/"}]},{"title":"rabbitmq消息去重及防丢失解决方案","slug":"rabbitmq消息去重及防丢失解决方案","date":"2019-03-22T03:38:54.000Z","updated":"2021-04-26T13:07:10.006Z","comments":true,"path":"posts/1e602a25.html","link":"","permalink":"https://cloudintheking.github.io/posts/1e602a25.html","excerpt":"","text":"- - 个人笔记，如有描述不当，欢迎留言指出~ 前提我们知道一个电商项目里时刻都有海量的消息通知，比如顾客注册通知、签到通知、下单通知等等，而我们公司的电商项目更加复杂，包含了客户端、门店端以及供应商端三端，各种各样的消息通知游走在各个服务模块间。如果每个模块都要实现一套消息通知的功能，那无疑是多余的。所以我把各模块的消息功能提取出来独立成一个服务模块，就像一个快递员，把各模块的消息准确投递至各端。我采用了自己熟悉的rabbitmq来实现消息功能，当模块开发完交差时，组长冷不丁来了句：消息去重以及防丢失机制实现了没？w(ﾟДﾟ)w好吧，赶紧去实现。 消息去重依我的经验来看，在消费端去重比较好。因为即使生产端保证投递到rabbitmq上的消息是不重复的，但rabbitmq服务器有可能由于系统或网络原因导致消息重复推送到消费端，所以生产端去重是不可靠的，应当在消费端去重。 怎么解决呢？我的方案是在生产端投递消息的同时，传入correlationId关联id，在消费端接收消息后，从message的messageProperties中拿到correlationId，再根据correlationId从db中查询是否有相关记录。如果有，则说明这条消息已被我们消费过，直接ack，不进行业务处理；没有，那就把消息内容和correlationId存入表中，然后ack。 这里说明一下，我把消息的接收和业务处理分开来了。消息监听器只负责监听队列消息，并将其存至db中。在另外的任务线程里，从db中取消息记录进去业务处理，如果业务处理中出现异常，结合elasticsearch实现异常报警（这部分还没做，目前还只是记录下错误信息及消息内容）。 why?为啥分开处理，其实一开始的设计中消息接收和处理是写在一起的，消息处理成功回复ack，处理异常回复nack。但会有一个严重的问题，但测试环境中，我们发现总有那么几条消息卡在队列里，就因为处理异常回复nack，消息一直在重入队，严重消耗rabbitmq服务器的性能！所以说，大部分异常的消息，都不能指望把消息重推到别的消费端就能处理成功了，所以消息接收和处理分开来是比较好的。 方案是有了，但具体代码怎么实现呢？生产端关键代码：1234567891011121314public void send(String routingKey, String msg) &#123; RabbitTemplate rabbitTemplate = applicationContext.getBean(\"rabbitTemplate\", RabbitTemplate.class); rabbitTemplate.setReturnCallback(this); log.info(\"消息发送内容 : \" + msg); CorrelationData correlationId = new CorrelationData(UUID.randomUUID().toString()); rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123; if (!ack) &#123; throw new RuntimeException(\"send error \" + cause); &#125; else &#123; log.info(\"send() 消息发送成功 \"); &#125; &#125;); rabbitTemplate.convertAndSend(\"amq.topic\", routingKey, msg, correlationId); &#125; 我们点开rabbitTemplate.convertAndSend方法123public void convertAndSend(String exchange, String routingKey, Object object, CorrelationData correlationData) throws AmqpException &#123; this.send(exchange, routingKey, this.convertMessageIfNecessary(object), correlationData); &#125; 看到没，convertAndSend方法是以Object来接收消息内容，它内部调用的send方法最终还是把Object类转成Message类从上图可以看的出，Message包含了ENCODING（编码方式）、SERIALIZER_MESSAGE_CONVERTER（序列化消息转换器）、messageProperties（消息属性）、body（消息内容），队列里消息存放着这些东东。我们再看看MessageProperties里放着什么1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 public class MessageProperties implements Serializable &#123; private static final long serialVersionUID = 1619000546531112290L; public static final String CONTENT_TYPE_BYTES = \"application/octet-stream\"; public static final String CONTENT_TYPE_TEXT_PLAIN = \"text/plain\"; public static final String CONTENT_TYPE_SERIALIZED_OBJECT = \"application/x-java-serialized-object\"; public static final String CONTENT_TYPE_JSON = \"application/json\"; public static final String CONTENT_TYPE_JSON_ALT = \"text/x-json\"; public static final String CONTENT_TYPE_XML = \"application/xml\"; public static final String SPRING_BATCH_FORMAT = \"springBatchFormat\"; public static final String BATCH_FORMAT_LENGTH_HEADER4 = \"lengthHeader4\"; public static final String SPRING_AUTO_DECOMPRESS = \"springAutoDecompress\"; public static final String X_DELAY = \"x-delay\"; public static final String DEFAULT_CONTENT_TYPE = \"application/octet-stream\"; public static final MessageDeliveryMode DEFAULT_DELIVERY_MODE; public static final Integer DEFAULT_PRIORITY; private final Map&lt;String, Object&gt; headers = new HashMap(); private volatile Date timestamp; private volatile String messageId; private volatile String userId; private volatile String appId; private volatile String clusterId; private volatile String type; private volatile String correlationId; private volatile String replyTo; private volatile String contentType = \"application/octet-stream\"; private volatile String contentEncoding; private volatile long contentLength; private volatile boolean contentLengthSet; private volatile MessageDeliveryMode deliveryMode; private volatile String expiration; private volatile Integer priority; private volatile Boolean redelivered; private volatile String receivedExchange; private volatile String receivedRoutingKey; private volatile String receivedUserId; private volatile long deliveryTag; private volatile boolean deliveryTagSet; private volatile Integer messageCount; private volatile String consumerTag; private volatile String consumerQueue; private volatile Integer receivedDelay; private volatile MessageDeliveryMode receivedDeliveryMode; private volatile boolean finalRetryForMessageWithNoId; private transient volatile Type inferredArgumentType; private transient volatile Method targetMethod; private transient volatile Object targetBean;&#125; 果然correlationId就在这里，然后看到这里我就没继续深入了，原以为rabbitTemplate.convertAndSend方法会自动将correlationId放入messageProperties中，结果表明我错了。在消费端拿到的correlationId为null。也就是说，convertAndSend方法里correlationId根本就没有被放进去的，大家感兴趣的话可以看看源码，这里就不说了。 问题找出来就好办了123456789101112131415161718public void send(String routingKey, String msg) &#123; RabbitTemplate rabbitTemplate = applicationContext.getBean(\"rabbitTemplate\", RabbitTemplate.class); rabbitTemplate.setReturnCallback(this); log.info(\"消息发送内容 : \" + msg); CorrelationData correlationId = new CorrelationData(UUID.randomUUID().toString()); rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123; if (!ack) &#123; throw new RuntimeException(\"send error \" + cause); &#125; else &#123; log.info(\"send() 消息发送成功 \"); &#125; &#125;); Message message = MessageBuilder.withBody(msg.getBytes()) .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN) .setCorrelationId(correlationId.toString()) .build(); rabbitTemplate.convertAndSend(\"amq.topic\", routingKey, message, correlationId); &#125; 直接构建Message类，手动传入correlationId总行了吧。在消费端从Message里拿到correlationId，再从db查询就行了。好了，到这里去重机制就实现了😁 消息防丢失rabbitmq是支持队列、消息的持久化的。即便rabbitmq突然挂了，那些尚在队列未能推送的消息在rabbitmq重启后也是能够继续推送的，所以丢失问题一般不出现在rabbitmq上。 rabbitmq将消息从队列推到消费端后，需要有一个回应告诉它队列里的这条消息的去留。主要有两种方式： auto: 自动回应，消息在发送给消费端后立即确认 manual 手动回应，消息消费正常后由消费端返回ack;或消费异常返回nack,将消息重入队；或返回reject,丢弃该条消息 springboot的yaml配置123456789101112rabbitmq: host: 127.0.0.1 port: 5672 username: admin password: admin publisher-confirms: true #开启confirmcallback publisher-returns: true #开启returncallback listener: simple: acknowledge-mode: manual direct: acknowledge-mode: MANUAL 另外，如果消息在消费的时候，消费端与rabbitmq的连接中断了，那这条消息会被重新放回队列进行推送，这个时候我们的去重机制就起作用了；如果消费的时候，消费端死机了，长时间不回应rabbitmq，这时候我们可以将该消息转至死信队列，防止原队列阻塞。死信队列，这里也不做介绍，有兴趣百度呗。所以消费端出现消息丢失的可能性也不大，问题就可能出在生产端。看看下面这张图左边P代表生产端，中间是rabbitmq，右边是消费端，绿色的X是交换机，红色的是队列，用过rabbitmq的小伙伴肯定一目了然了。 rabbitmq 整个消息投递的路径为：producer-&gt;rabbitmq broker cluster-&gt;exchange-&gt;queue-&gt;consumer 生产端投递消息到rabbitmq里，rabbitmq将消息发到交换机中，交换机再根据路由键将消息最终送到队列中，队列取出消息推送到消费端。只有最终抵达队列的消息才是可靠的，不会丢失。所以我们要实现的就是保证生产端的消息务必推送到rabbitmq的队列中。 那么生产端是怎么知道自己的消费准确投递到了队列中呢？rabbitmq返回了两个回调给生产端。 message 从 producer 到 rabbitmq broker cluster 则会返回一个 confirmCallback message 从 exchange-&gt;queue 投递失败则会返回一个 returnCallback 。我们将利用这两个 callback 控制消息的最终一致性和部分纠错能力。 解决方案生产端在投递消息前，先将消息内容、投递状态、重试次数记录在db中，然后在两个回调中修改记录状态。另外再开一个任务线程去取db中记录的失败消息，进行重新投递。 代码实现失败消息记录实体类：123456789101112131415161718192021222324252627282930313233343536373839404142/** * @time: 2019/2/18 9:14 * @author: hl * @descripe: 失败消息记录 * @version: 1.0 */Entity@Table(name = \"t_failure_mq_record\")@Data@NoArgsConstructor@EntityListeners(AuditingEntityListener.class)public class FailureMqRecord extends Uuid &#123; /** * 失败消息内容 */ private String message; /** * 重试次数 */ @Column(name = \"retry_time\") private Integer retryTime; /** * 消息状态 1:投递成功 2：投递失败 */ private Integer status; /** * 关联id */ private String correlationId; /** * 创建时间 */ @CreatedDate @Column(name = \"create_time\", updatable = false) private Date createTime; public FailureMqRecord(String message) &#123; this.message = message; &#125;&#125; rabbitmq发送器：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @time: 2019/2/13 9:47 * @author: hl * @descripe: * @version: 1.0 */@Component@Slf4jpublic class RabbitMqSender implements RabbitTemplate.ReturnCallback &#123; @Autowired private ApplicationContext applicationContext; @Autowired private FailureMqRecordRepository failureMqRecordRepository; public void send(String routingKey, FailureMqRecord failureMqRecord) &#123; RabbitTemplate rabbitTemplate = applicationContext.getBean(\"rabbitTemplate\", RabbitTemplate.class); //设置当前实例为rabbitmqtemplate的returncallback rabbitTemplate.setReturnCallback(this); rabbitTemplate.setConfirmCallback(((correlationData1, ack, cause) -&gt; &#123; if (!ack) &#123; //投递至broker失败 failureMqRecord.setStatus(2);//设为投递失败 failureMqRecordRepository.save(failureMqRecord); &#125; &#125;)); Message message = MessageBuilder.withBody(failureMqRecord.getMessage().getBytes()) .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN) .setCorrelationId(failureMqRecord.getCorrelationId()) .build(); rabbitTemplate.convertAndSend(\"amq.topic\", routingKey, message, new CorrelationData(failureMqRecord.getCorrelationId())); failureMqRecord.setStatus(1);//设为投递成功 failureMqRecord.setRetryTime(failureMqRecord.getRetryTime() + 1);//重试次数+1 failureMqRecordRepository.save(failureMqRecord); &#125; /** * 消息由exchang未能正确投递到queue时触发回调 * * @param message * @param replyCode * @param replyText * @param exchange * @param routingKey */ @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) throws BusinessException &#123; FailureMqRecord mq = failureMqRecordRepository.findByCorrelationId(message.getMessageProperties().getCorrelationId()); mq.setStatus(2); failureMqRecordRepository.save(mq); log.error(\"审批消息：&#123;&#125; 投递至路由：&#123;&#125;失败\", message.getBody(), routingKey); &#125;&#125; 任务线程，实现消息重试机制：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @time: 2019/2/18 10:10 * @author: huanglong * @descripe: 消息重发定时器 * @version: 1.0 */@Component@Slf4jpublic class MqScheduler &#123; @Autowired private RabbitMqSender rabbitMqSender; @Autowired private ApprovalMqRepository failureMqRecordRepository; @Autowired private RedisDistributedLock redisDistributedLock; /** * 每3分钟执行一次 * 将投递失败消息重新投递到rabbitmq */ @Scheduled(cron = \"* */3 * * * ?\") void push() &#123; List&lt;FailureMqRecord&gt; failureMqRecords = failureMqRecordRepository.findAll() .stream() .filter(failureMqRecord -&gt; &#123; if (failureMqRecord.getRetryTime() == 3) &#123; log.error(\"警告！该消息已重投3次失败，请人工处理，消息记录uuid:&#123;&#125;\", failureMqRecord.getUuid()); &#125; //过滤出重试次数不超过3次、状态为2的消息记录 if (failureMqRecord.getRetryTime() &lt; 3 &amp;&amp; failureMqRecord.getStatus() == 0) &#123; return true; &#125; return false; &#125;) .collect(Collectors.toList()); Iterator&lt;FailureMqRecord&gt; mqIterator = failureMqRecords.iterator(); while (mqIterator.hasNext()) &#123; FailureMqRecord failureMqRecord = mqIterator.next(); //获取🔒,过期时间5秒，不重复获取 if (redisDistributedLock.lock(failureMqRecord.getUuid(), 5000L, 0, 1000L)) &#123; // 因为有可能上一个线程刚释放该记录的锁，就被当前先线程获取到该记录的锁，导致记录已被 FailureMqRecord failurelatest = failureMqRecordRepository.findById(failureMqRecord.getUuid()).orElse(null); ApprovalPushMessage pushMessage = JSON.parseObject(failurelatest.getMessage(), ApprovalPushMessage.class); //当前时间距离该记录最近一次修改时间的间隔，防止上个线程重试过后，当前线程又重试一次 long lastUpdatePeriod = System.currentTimeMillis() - failurelatest.getUpdateTime().getTime(); //距离上次更新间隔 //重判断记录是否符合条件,重试次数小于3、状态为投递失败、距离上次重试不能少于2分钟 if (failurelatest.getRetryTime() &lt; 3 &amp;&amp; failurelatest.getStatus() == 2 &amp;&amp; lastUpdatePeriod &gt; 2 * 60 * 1000) &#123; rabbitMqSender.send(\"approval.create\", failureMqRecord); &#125; //释放🔒 redisDistributedLock.releaseLock(failureMqRecord.getUuid()); &#125; &#125; &#125;&#125; 聪明的小伙伴看到这里，会发现任务线程里还用到了分布式🔒。为啥还要加分布式锁，因为是分布式架构啊，会有多个相同定时器从db里取记录处理，如果不加分布式锁，那真的要乱套了。因为redis用的多，就用redis来实现分布式锁了，zookeeper啥的，有空再研究了。redis分布式锁的代码实现，网上有很多资源，我这里就不贴了，嘿嘿 好了，到这里rabbitmq的去重以及防丢失方案已经实现了，如果你有更好的解决方案或者指出我方案的不足，欢迎留言讨论😁","categories":[{"name":"后端笔记","slug":"后端笔记","permalink":"https://cloudintheking.github.io/categories/后端笔记/"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://cloudintheking.github.io/tags/rabbitmq/"}]},{"title":"记录一次微服务异步化实现过程","slug":"记录一次微服务异步化实现过程","date":"2019-03-21T03:54:04.000Z","updated":"2021-04-26T13:07:10.006Z","comments":true,"path":"posts/f445f2a6.html","link":"","permalink":"https://cloudintheking.github.io/posts/f445f2a6.html","excerpt":"","text":"- - 个人笔记，如有描述不当，欢迎留言指出~ 前提公司使用springcloud开发微服务，我在开发审批模块中，其中一个新增审批请求中请求了其他几个模块，使用feign接口依次请求，最后发现请求平均耗时1.5s。这速度怎么能忍，于是进行了异步化改造。 异步化同步版关键代码12345678910111213logger.info(\"rpc请求开始\"); long rpcstart = System.currentTimeMillis(); StoreStaffDTO staffDTO = staffClient.getStaffDTO(userDTO.getUuid()); //获取门店员工信息 SupplierDTO supplierDTO = supplierClient.getSupplierDTO(userDTO.getSupplierCode()); //获取供应商信息 StoreDTO staffStoreDTO = storeClient.getStoreDTO(userDTO.getStoreUuid()); //获取员工所在门店信息 CustomerInfoDTO customerInfoDTO = customerInfoClient.getCustomerInfo(approval.getCustomerUuid()); //获取顾客信息 StoreDTO inStoreDto = ObjectUtils.isEmpty(approval.getInStoreUuid()) ? null : storeClient.getStoreDTO(approval.getInStoreUuid());//获取客户转入门店信息 ServerDto serverDto = ObjectUtils.isEmpty(approval.getServerUuid()) ? null : serveClient.getServeSpecTypeByuuid(approval.getServerUuid()); //获取服务信息 CustAccountDto custAccountDto = ObjectUtils.isEmpty(approval.getCustCardUuid()) ? null : accountClient.getCustAccount(approval.getCustCardUuid()); //获取顾客账户信息 long rpcend = System.currentTimeMillis(); logger.info(\"rpc请求结束，耗时：&#123;&#125;毫秒\", (rpcend - rpcstart)); console 从打印日志中可以看出，由于网络波动性，请求耗时可能只要1秒也可能将近4秒，但rpc请求总是会占总耗时的90%左右，所以影响新增审批的请求的瓶颈就是这些rpc请求，下面我使用异步线程发送这些rpc请求。 异步版关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102logger.info(\"rpc请求开始\"); long rpcstart = System.currentTimeMillis(); Approval approvalFina = approval; CompletableFuture&lt;StoreDTO&gt; storeDTOCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); return storeClient.getStoreDTO(userDTO.getStoreUuid()); &#125; catch (Exception e) &#123; logger.error(\"获取门店信息rpc错误，原因：\", e); throw e; &#125; &#125;); CompletableFuture&lt;StoreDTO&gt; inStoreDTOCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); if (!ObjectUtils.isEmpty(approvalFina.getInStoreUuid())) &#123; return storeClient.getStoreDTO(approvalFina.getInStoreUuid()); &#125; return null; &#125; catch (Exception e) &#123; logger.error(\"获取转入门店信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture&lt;SupplierDTO&gt; supplierDTOCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); return supplierClient.getSupplierDTO(userDTO.getSupplierCode()); &#125; catch (Exception e) &#123; logger.error(\"获取供应商信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture&lt;StoreStaffDTO&gt; staffDTOCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); return staffClient.getStaffDTO(userDTO.getUuid()); &#125; catch (Exception e) &#123; logger.error(\"获取门店员工信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture&lt;CustomerInfoDTO&gt; customerInfoDTOCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); return customerInfoClient.getCustomerInfo(approvalFina.getCustomerUuid()); &#125; catch (Exception e) &#123; logger.error(\"获取顾客信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture&lt;ServerDto&gt; serverDtoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); if (!ObjectUtils.isEmpty(approvalFina.getServerUuid())) &#123; return serveClient.getServeSpecTypeByuuid(approvalFina.getServerUuid()); &#125; return null; &#125; catch (Exception e) &#123; logger.error(\"获取服务信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture&lt;CustAccountDto&gt; custAccountDtoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); if (!ObjectUtils.isEmpty(approvalFina.getCustCardUuid())) &#123; return accountClient.getCustAccount(approvalFina.getCustCardUuid()); &#125; return null; &#125; catch (Exception e) &#123; logger.error(\"获取顾客账户信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture.allOf(storeDTOCompletableFuture, inStoreDTOCompletableFuture, serverDtoCompletableFuture, supplierDTOCompletableFuture, staffDTOCompletableFuture, customerInfoDTOCompletableFuture, custAccountDtoCompletableFuture); StoreStaffDTO staffDTO = null;//员工信息 SupplierDTO supplierDTO = null; //供应商信息 StoreDTO staffStoreDTO = null;//员工所在门店信息 CustomerInfoDTO customerInfoDTO = null; //顾客信息 StoreDTO inStoreDto = null;//顾客转入门店信息 ServerDto serverDto = null; //服务信息 CustAccountDto custAccountDto = null; //顾客账户信息 try &#123; staffStoreDTO = storeDTOCompletableFuture.get(); inStoreDto = inStoreDTOCompletableFuture.get(); staffDTO = staffDTOCompletableFuture.get(); supplierDTO = supplierDTOCompletableFuture.get(); customerInfoDTO = customerInfoDTOCompletableFuture.get(); serverDto = serverDtoCompletableFuture.get(); custAccountDto = custAccountDtoCompletableFuture.get(); &#125; catch (InterruptedException e) &#123; logger.error(\"线程中断错误信息：&#123;&#125;\", e); &#125; catch (ExecutionException e) &#123; logger.error(\"线程执行错误信息：&#123;&#125;\", e); &#125; long rpcend = System.currentTimeMillis(); logger.info(\"rpc请求结束，耗时：&#123;&#125;毫秒\", (rpcend - rpcstart)); console exception分析what😨!竟然报未授权登录异常，不可能，feign请求里应该是带了请求头阿，下面拓展一些知识。 知识拓展completableFuturecompletableFuture扩展了Future的功能，并且实现了线程间同步的功能，我们用它提供的语法，可以很简单的实现异步编程。 oauth2框架里引用了spring security以及oauth2来实现授权认证服务,所以客户请求是要带上Authorization请求头的。 feignfeign的本质，其实就是使用httpclient帮我们封装好了http请求。所以调用feign接口的方法就是发起一次http请求而已。如果不做处理的，那么feign发送的http请求里是没有Authorization请求头的。 RequestInterceptorRequestInterceptor是feign提供的一个拦截器放出我的配置：123456789101112131415@Configurationpublic class FeignOauth2RequestInterceptor implements RequestInterceptor &#123; private final String AUTHORIZATION_HEADER = \"Authorization\"; private final String BEARER_TOKEN_TYPE = \"Bearer\"; @Override public void apply(RequestTemplate requestTemplate) &#123; SecurityContext securityContext = SecurityContextHolder.getContext(); Authentication authentication = securityContext.getAuthentication(); if (authentication != null &amp;&amp; authentication.getDetails() instanceof OAuth2AuthenticationDetails) &#123; OAuth2AuthenticationDetails details = (OAuth2AuthenticationDetails) authentication.getDetails(); requestTemplate.header(AUTHORIZATION_HEADER, String.format(\"%s %s\", BEARER_TOKEN_TYPE, details.getTokenValue())); &#125; &#125;&#125; 拦截器的作用就是从securityContext拿到当前请求用户的认证信息authentication，然后为feign的请求模板·requestTemplate·赋上Authorization请求头。 断点跟踪断点1打个断点跟进，看看拦截后feign执行了哪些操作，关键位置如下图：可以看到feign将requestTemplate封装成request对象，并最终被client执行得到response,里面详细细节就不深入。从这里我们可以知道，调用feign发送的请求是携带Authorization请求头的,这样模块间发起请求就不会报未授权错误了。 断点2所以按道理是不应该报用户未登录授权异常的，所以我们在拦截器打个端点,看看requestTemplate到底有没有被赋上请求头。what😮!这不是推翻了我的认知吗,眼神逐渐呆滞😑开个玩笑，authentication从securityContext里获取，securityContext从SecurityContextHolder静态方法中获取 从图中可以看出securityContext是从strategy里拿到的。SecurityContextHolderStrategy是spring security安全上下文的存取策略。SecurityContextHolderStrategy接口有三个实现类，对应三种实现策略： GlobalSecurityContextHolderStrategy：使用 一个静态变量存放securityContext ThreadLocalSecurityContextHolderStrategy：使用ThreadLocal存放securityContext InheritableThreadLocalSecurityContextHolderStrategy：使用InheritableThreadLocal存放securityContext断点3那我当前环境里SecurityContextHolder里使用的是哪个策略呢，打个断点 恍然大悟！🤣原来采用的是ThreadLocalSecurityContextHolderStrategy还记得我异步改造里怎么写的吗123456789CompletableFuture&lt;StoreDTO&gt; storeDTOCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); return storeClient.getStoreDTO(userDTO.getStoreUuid()); &#125; catch (Exception e) &#123; logger.error(\"获取门店信息rpc错误，原因：\", e); throw e; &#125; &#125;); 我将调用feign请求代码写在CompletableFuture.supplyAsync(()-&gt;{})中,而CompletableFuture里默认线程池会分配新线程去执行任务，所以新线程里是没有securityContext的线程副本的！所以在拦截器里才会取到空的securityContext，最终报未授权登录异常！bingo😎 最终异步版关键代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112logger.info(\"rpc请求开始\"); long rpcstart = System.currentTimeMillis(); SecurityContext securityContext = SecurityContextHolder.getContext();//从当前请求线程中拿到securityContext安全上下文 Approval approvalFina = approval; CompletableFuture&lt;StoreDTO&gt; storeDTOCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); SecurityContextHolder.setContext(securityContext); //设置securityContext安全上下文线程副本 return storeClient.getStoreDTO(userDTO.getStoreUuid()); &#125; catch (Exception e) &#123; logger.error(\"获取门店信息rpc错误，原因：\", e); throw e; &#125; &#125;); CompletableFuture&lt;StoreDTO&gt; inStoreDTOCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); if (!ObjectUtils.isEmpty(approvalFina.getInStoreUuid())) &#123; SecurityContextHolder.setContext(securityContext); return storeClient.getStoreDTO(approvalFina.getInStoreUuid()); &#125; return null; &#125; catch (Exception e) &#123; logger.error(\"获取转入门店信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture&lt;SupplierDTO&gt; supplierDTOCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); SecurityContextHolder.setContext(securityContext); return supplierClient.getSupplierDTO(userDTO.getSupplierCode()); &#125; catch (Exception e) &#123; logger.error(\"获取供应商信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture&lt;StoreStaffDTO&gt; staffDTOCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); SecurityContextHolder.setContext(securityContext); return staffClient.getStaffDTO(userDTO.getUuid()); &#125; catch (Exception e) &#123; logger.error(\"获取门店员工信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture&lt;CustomerInfoDTO&gt; customerInfoDTOCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); SecurityContextHolder.setContext(securityContext); return customerInfoClient.getCustomerInfo(approvalFina.getCustomerUuid()); &#125; catch (Exception e) &#123; logger.error(\"获取顾客信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture&lt;ServerDto&gt; serverDtoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); if (!ObjectUtils.isEmpty(approvalFina.getServerUuid())) &#123; SecurityContextHolder.setContext(securityContext); return serveClient.getServeSpecTypeByuuid(approvalFina.getServerUuid()); &#125; return null; &#125; catch (Exception e) &#123; logger.error(\"获取服务信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture&lt;CustAccountDto&gt; custAccountDtoCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; logger.info(\"当前线程名：&#123;&#125;\", Thread.currentThread().getName()); if (!ObjectUtils.isEmpty(approvalFina.getCustCardUuid())) &#123; SecurityContextHolder.setContext(securityContext); return accountClient.getCustAccount(approvalFina.getCustCardUuid()); &#125; return null; &#125; catch (Exception e) &#123; logger.error(\"获取顾客账户信息rpc错误，原因：&#123;&#125;\", e); throw e; &#125; &#125;); CompletableFuture.allOf(storeDTOCompletableFuture, inStoreDTOCompletableFuture, serverDtoCompletableFuture, supplierDTOCompletableFuture, staffDTOCompletableFuture, customerInfoDTOCompletableFuture, custAccountDtoCompletableFuture); StoreStaffDTO staffDTO = null;//员工信息 SupplierDTO supplierDTO = null; //供应商信息 StoreDTO staffStoreDTO = null;//员工所在门店信息 CustomerInfoDTO customerInfoDTO = null; //顾客信息 StoreDTO inStoreDto = null;//顾客转入门店信息 ServerDto serverDto = null; //服务信息 CustAccountDto custAccountDto = null; //顾客账户信息 try &#123; staffStoreDTO = storeDTOCompletableFuture.get(); inStoreDto = inStoreDTOCompletableFuture.get(); staffDTO = staffDTOCompletableFuture.get(); supplierDTO = supplierDTOCompletableFuture.get(); customerInfoDTO = customerInfoDTOCompletableFuture.get(); serverDto = serverDtoCompletableFuture.get(); custAccountDto = custAccountDtoCompletableFuture.get(); &#125; catch (InterruptedException e) &#123; logger.error(\"线程中断错误信息：&#123;&#125;\", e); &#125; catch (ExecutionException e) &#123; logger.error(\"线程执行错误信息：&#123;&#125;\", e); &#125; long rpcend = System.currentTimeMillis(); logger.info(\"rpc请求结束，耗时：&#123;&#125;毫秒\", (rpcend - rpcstart)); console 可以看到rpc请求的耗时被平均缩短到500毫秒内😁 CompletableFuture学习可以看这篇👉here,我觉得这位博主写的还行。","categories":[{"name":"后端笔记","slug":"后端笔记","permalink":"https://cloudintheking.github.io/categories/后端笔记/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://cloudintheking.github.io/tags/微服务/"}]},{"title":"安装rabbitmq碰到的一些错误","slug":"安装rabbitmq碰到的一些错误","date":"2018-08-25T07:25:44.000Z","updated":"2021-04-26T13:07:09.988Z","comments":true,"path":"posts/f1b4514.html","link":"","permalink":"https://cloudintheking.github.io/posts/f1b4514.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ 安装请看我的这篇windows下安装rabbitmq the first and the last!!!你觉得rabbitmq服务启动没报错就大功告成了？no，you’re so naive我尝试run rabbitmq-plugin enable rabbitmq_management来开启管理插件，但是并不能打开管理页面，而且rabbitmqctl的相关命令也都报错。为此我翻遍了国内大大小小的论坛博客，解决方案是五花八门，但仍不能完全解决我的问题，所以我开始怀疑人生。当我一筹莫展时，我留意到其中一个错误run rabbitmqctl status时,错误提示是这样的：1Starting node rabbit@DESKTOP-0S1RKNE ... ** (ArgumentError) argument error (stdlib) io_lib.erl:170: :io_lib.format(' * effective user\\'s home directory: ~s~n', [[67, 58, 92, 85, 115, 101, 114, 115, 92, 19975, 23480, 26827]]) src/rabbit_misc.erl:670: :rabbit_misc.\"-format_many/1-lc$^0/1-0-\"/1 src/rabbit_misc.erl:670: :rabbit_misc.\"-format_many/1-lc$^0/1-0-\"/1 src/rabbit_misc.erl:670: :rabbit_misc.format_many/1 (rabbitmqctl) lib/rabbitmqctl.ex:349: RabbitMQCtl.get_node_diagnostics/1 (rabbitmqctl) lib/rabbitmqctl.ex:307: RabbitMQCtl.format_error/3 (rabbitmqctl) lib/rabbitmqctl.ex:43: RabbitMQCtl.main/1 (elixir) lib/kernel/cli.ex:76: anonymous fn/3 in Kernel.CLI.exec_fun/2 看字面意思是我参数错误，我一开始没明白什么意思直到我在stack overflow 上看到跟我同样的错误，不像国内论坛上尽说些有的没的，人老外就简单的这么一句 如果你的用户名不是英文，把它改成英文。 再回顾下错误提示，原来是路径参数错了。唉，啥也不说了，悔不当初啊，就不该设置中文用户名！！ 如何修改用户名及用户文件夹名，我是参考这篇博文的https://blog.csdn.net/zhang_jinhe/article/details/40624847然后卸载rabbitmq重装，所有问题都解决了✌ feeling我们往往认为错误多是因为错误因素多，但其实一个错误往往是由另一个错误引起的，它本身其实并不是错误因素。所以在解决问题的时候，不能盲目地企图去查找所有错误因素，而是应该花时间去找到那个关键因素，解决它，那剩下的错误就悉数解决了。moreover，英语能力也很重要哈😄","categories":[{"name":"问题总结篇","slug":"问题总结篇","permalink":"https://cloudintheking.github.io/categories/问题总结篇/"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://cloudintheking.github.io/tags/rabbitmq/"}]},{"title":"windows下安装rabbitmq","slug":"windows下安装rabbitmq","date":"2018-08-25T06:32:17.000Z","updated":"2021-04-26T13:07:09.982Z","comments":true,"path":"posts/cb85a86.html","link":"","permalink":"https://cloudintheking.github.io/posts/cb85a86.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ erlang rabbitmq是基于erlang开发，安装rabbitmq前必须安装erlang环境 下载erlang20.1并安装 安装后切记配置环境变量，新建系统环境变量ERLANG_HOME,值为你erlang的安装路径(如F:\\Environment\\erl9.1),然后向系统环境变量path追加内容%ERLANG_HOME%\\bin rabbitmq安装 下载rabbitmq3.7.3并安装 erlang和rabbitmq不同版本间搭配可能存在bug，但至少我装的erlang20.1和rabbitmq3.7.3是没问题的 环境变量新建系统环境变量RABBITMQ_SERVER,值为你rabbitmq的安装路径(如F:\\Environment\\RabbitMQ\\rabbitmq_server-3.7.3),然后向系统环境变量path追加内容%RABBITMQ_SERVER%\\sbin 同步Erlang Cookies 这是最重要的一步，rabbitmq 的集群节点和命令行工具都是使用了erlang cookies来作为认证的 这个cookie文件有两份，这两份cookie内容要保持一致 erlang20.2之前： 一份在C:\\Users\\%USERNAME%\\.erlang.cookie 一份在C:\\Windows\\.erlang.cookie erlang20.2之后： 一份在C:\\Users\\%USERNAME%\\.erlang.cookie 一份在C:\\WINDOWS\\system32\\config\\systemprofile\\.erlang.cookie 安装服务并运行rabbitmq在安装时默认启动了服务，但这个服务可能会有问题，比如上面说的cookie要一致，如果不一致便启动了服务，那这个服务肯定是有问题的。 第一步1234567#切记管理员身份f: #进入f盘cd F:\\Environment\\RabbitMQ\\rabbitmq_server-3.7.3\\sbin #进入rabbitmq批处理目录rabbitmq-service stop #停止rabbitmq服务rabbitmq-service remove #删除rabbitmq服务rabbitmq-service install #安装rabbitmq服务rabbitmq-service start #启动rabbitmq服务 如下图所示： 第二步1rabbitmqctl status #查看rabbitmq服务器状态 如下图所示： 第三步1rabbitmq-plugins enable rabbitmq_management #开启rabbitmq管理插件 如果你之前已经开启了插件，那么不会有变化，如下图所示： 如果你之前没有开启插件，如下图所示： 第四步12rabbitmq-service stop #停止rabbitmq服务rabbitmq-service start #启动rabbitmq服务使配置生效 最后在浏览器地址栏中输入http://localhost:15672，打开rabbitmq管理登录页面，默认用户名：guest，密码：guest 更多rabbitmq的详细安装介绍，see manual，以后有空我会翻译下这篇文章(^_^)","categories":[{"name":"环境安装篇","slug":"环境安装篇","permalink":"https://cloudintheking.github.io/categories/环境安装篇/"}],"tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://cloudintheking.github.io/tags/rabbitmq/"}]},{"title":"AVL树之c++实现","slug":"AVL树之c-实现","date":"2018-08-18T11:01:11.000Z","updated":"2021-04-26T13:07:09.998Z","comments":true,"path":"posts/942112fa.html","link":"","permalink":"https://cloudintheking.github.io/posts/942112fa.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ 头文件AVLTree.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#ifndef _AVL_TREE_HPP_#define _AVL_TREE_HPP_template &lt;class T&gt;class AVLTreeNode&#123; public: T key; // 关键字(键值) int height; // 高度 AVLTreeNode *left; // 左孩子 AVLTreeNode *right; // 右孩子 AVLTreeNode(T value, AVLTreeNode *l, AVLTreeNode *r): key(value), height(0),left(l),right(r)&#123;&#125;&#125;;template &lt;class T&gt;class AVLTree &#123; private: AVLTreeNode&lt;T&gt; *mRoot; // 根结点 public: AVLTree(); ~AVLTree(); // 获取树的高度 int height(); // 获取树的高度 int max(int a, int b); // 前序遍历\"AVL树\" void preOrder(); // 中序遍历\"AVL树\" void inOrder(); // 后序遍历\"AVL树\" void postOrder(); // (递归实现)查找\"AVL树\"中键值为key的节点 AVLTreeNode&lt;T&gt;* search(T key); // (非递归实现)查找\"AVL树\"中键值为key的节点 AVLTreeNode&lt;T&gt;* iterativeSearch(T key); // 查找最小结点：返回最小结点的键值。 T minimum(); // 查找最大结点：返回最大结点的键值。 T maximum(); // 将结点(key为节点键值)插入到AVL树中 void insert(T key); // 删除结点(key为节点键值) void remove(T key); // 销毁AVL树 void destroy(); // 打印AVL树 void print(); private: // 获取树的高度 int height(AVLTreeNode&lt;T&gt;* tree) ; // 前序遍历\"AVL树\" void preOrder(AVLTreeNode&lt;T&gt;* tree) const; // 中序遍历\"AVL树\" void inOrder(AVLTreeNode&lt;T&gt;* tree) const; // 后序遍历\"AVL树\" void postOrder(AVLTreeNode&lt;T&gt;* tree) const; // (递归实现)查找\"AVL树x\"中键值为key的节点 AVLTreeNode&lt;T&gt;* search(AVLTreeNode&lt;T&gt;* x, T key) const; // (非递归实现)查找\"AVL树x\"中键值为key的节点 AVLTreeNode&lt;T&gt;* iterativeSearch(AVLTreeNode&lt;T&gt;* x, T key) const; // 查找最小结点：返回tree为根结点的AVL树的最小结点。 AVLTreeNode&lt;T&gt;* minimum(AVLTreeNode&lt;T&gt;* tree); // 查找最大结点：返回tree为根结点的AVL树的最大结点。 AVLTreeNode&lt;T&gt;* maximum(AVLTreeNode&lt;T&gt;* tree); // LL：左左对应的情况(左单旋转)。 AVLTreeNode&lt;T&gt;* leftLeftRotation(AVLTreeNode&lt;T&gt;* k2); // RR：右右对应的情况(右单旋转)。 AVLTreeNode&lt;T&gt;* rightRightRotation(AVLTreeNode&lt;T&gt;* k1); // LR：左右对应的情况(左双旋转)。 AVLTreeNode&lt;T&gt;* leftRightRotation(AVLTreeNode&lt;T&gt;* k3); // RL：右左对应的情况(右双旋转)。 AVLTreeNode&lt;T&gt;* rightLeftRotation(AVLTreeNode&lt;T&gt;* k1); // 将结点(z)插入到AVL树(tree)中 AVLTreeNode&lt;T&gt;* insert(AVLTreeNode&lt;T&gt;* &amp;tree, T key); // 删除AVL树(tree)中的结点(z)，并返回被删除的结点 AVLTreeNode&lt;T&gt;* remove(AVLTreeNode&lt;T&gt;* &amp;tree, AVLTreeNode&lt;T&gt;* z); // 销毁AVL树 void destroy(AVLTreeNode&lt;T&gt;* &amp;tree); // 打印AVL树 void print(AVLTreeNode&lt;T&gt;* tree, T key, int direction);&#125;;#endif 源文件 AVLTree.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464#include \"AVLTree.h\"#include &lt;iomanip&gt;#include &lt;iostream&gt;using namespace std;/* * 构造函数 */template &lt;class T&gt;AVLTree&lt;T&gt;::AVLTree():mRoot(NULL)&#123;&#125;/* * 析构函数 */template &lt;class T&gt;AVLTree&lt;T&gt;::~AVLTree() &#123; destroy(mRoot);&#125;/* * 获取树的高度 */template &lt;class T&gt;int AVLTree&lt;T&gt;::height(AVLTreeNode&lt;T&gt;* tree) &#123; if (tree != NULL) return tree-&gt;height; return 0;&#125;template &lt;class T&gt;int AVLTree&lt;T&gt;::height() &#123; return height(mRoot);&#125;/* * 比较两个值的大小 */template &lt;class T&gt;int AVLTree&lt;T&gt;::max(int a, int b) &#123; return a&gt;b ? a : b;&#125;/* * 前序遍历\"AVL树\" */template &lt;class T&gt;void AVLTree&lt;T&gt;::preOrder(AVLTreeNode&lt;T&gt;* tree) const&#123; if(tree != NULL) &#123; cout&lt;&lt; tree-&gt;key &lt;&lt; \" \" ; preOrder(tree-&gt;left); preOrder(tree-&gt;right); &#125;&#125;template &lt;class T&gt;void AVLTree&lt;T&gt;::preOrder() &#123; preOrder(mRoot);&#125;/* * 中序遍历\"AVL树\" */template &lt;class T&gt;void AVLTree&lt;T&gt;::inOrder(AVLTreeNode&lt;T&gt;* tree) const&#123; if(tree != NULL) &#123; inOrder(tree-&gt;left); cout&lt;&lt; tree-&gt;key &lt;&lt; \" \" ; inOrder(tree-&gt;right); &#125;&#125;template &lt;class T&gt;void AVLTree&lt;T&gt;::inOrder() &#123; inOrder(mRoot);&#125;/* * 后序遍历\"AVL树\" */template &lt;class T&gt;void AVLTree&lt;T&gt;::postOrder(AVLTreeNode&lt;T&gt;* tree) const&#123; if(tree != NULL) &#123; postOrder(tree-&gt;left); postOrder(tree-&gt;right); cout&lt;&lt; tree-&gt;key &lt;&lt; \" \" ; &#125;&#125;template &lt;class T&gt;void AVLTree&lt;T&gt;::postOrder() &#123; postOrder(mRoot);&#125;/* * (递归实现)查找\"AVL树x\"中键值为key的节点 */template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::search(AVLTreeNode&lt;T&gt;* x, T key) const&#123; if (x==NULL || x-&gt;key==key) return x; if (key &lt; x-&gt;key) return search(x-&gt;left, key); else return search(x-&gt;right, key);&#125;template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::search(T key) &#123; return search(mRoot, key);&#125;/* * (非递归实现)查找\"AVL树x\"中键值为key的节点 */template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::iterativeSearch(AVLTreeNode&lt;T&gt;* x, T key) const&#123; while ((x!=NULL) &amp;&amp; (x-&gt;key!=key)) &#123; if (key &lt; x-&gt;key) x = x-&gt;left; else x = x-&gt;right; &#125; return x;&#125;template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::iterativeSearch(T key)&#123; return iterativeSearch(mRoot, key);&#125;/* * 查找最小结点：返回tree为根结点的AVL树的最小结点。 */template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::minimum(AVLTreeNode&lt;T&gt;* tree)&#123; if (tree == NULL) return NULL; while(tree-&gt;left != NULL) tree = tree-&gt;left; return tree;&#125;template &lt;class T&gt;T AVLTree&lt;T&gt;::minimum()&#123; AVLTreeNode&lt;T&gt; *p = minimum(mRoot); if (p != NULL) return p-&gt;key; return (T)NULL;&#125; /* * 查找最大结点：返回tree为根结点的AVL树的最大结点。 */template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::maximum(AVLTreeNode&lt;T&gt;* tree)&#123; if (tree == NULL) return NULL; while(tree-&gt;right != NULL) tree = tree-&gt;right; return tree;&#125;template &lt;class T&gt;T AVLTree&lt;T&gt;::maximum()&#123; AVLTreeNode&lt;T&gt; *p = maximum(mRoot); if (p != NULL) return p-&gt;key; return (T)NULL;&#125;/* * LL：左左对应的情况(左单旋转)。 * * 返回值：旋转后的根节点 */template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::leftLeftRotation(AVLTreeNode&lt;T&gt;* k2)&#123; AVLTreeNode&lt;T&gt;* k1=k2-&gt;left; k2-&gt;left=k1-&gt;right; k1-&gt;right=k2; k2-&gt;height=max(height(k2-&gt;left),height(k2-&gt;right))+1; k1-&gt;height=max(height(k1-&gt;left),height(k1-&gt;right))+1; return k1;&#125;/* * RR：右右对应的情况(右单旋转)。 * * 返回值：旋转后的根节点 */template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::rightRightRotation(AVLTreeNode&lt;T&gt;* k1)&#123; AVLTreeNode&lt;T&gt;* k2=k1-&gt;right; k1-&gt;right=k2-&gt;left; k2-&gt;left=k1; k1-&gt;height=max(height(k1-&gt;left),height(k1-&gt;right))+1; k2-&gt;height=max(height(k2-&gt;left),height(k2-&gt;right))+1; return k2;&#125;/* * LR：左右对应的情况(左双旋转)。 * * 返回值：旋转后的根节点 */template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::leftRightRotation(AVLTreeNode&lt;T&gt;* k3)&#123; k3-&gt;left=rightRightRotation(k3-&gt;left); return leftLeftRotation(k3);&#125;/* * RL：右左对应的情况(右双旋转)。 * * 返回值：旋转后的根节点 */template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::rightLeftRotation(AVLTreeNode&lt;T&gt;* k1)&#123; k1-&gt;right = leftLeftRotation(k1-&gt;right); return rightRightRotation(k1);&#125;/* * 将结点插入到AVL树中，并返回根节点 * * 参数说明： * tree AVL树的根结点 * key 插入的结点的键值 * 返回值： * 根节点 */template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::insert(AVLTreeNode&lt;T&gt;* &amp;tree, T key)&#123; if (tree == NULL) &#123; // 新建节点 tree = new AVLTreeNode&lt;T&gt;(key, NULL, NULL); if (tree==NULL) &#123; cout &lt;&lt; \"ERROR: create avltree node failed!\" &lt;&lt; endl; return NULL; &#125; &#125; else if (key &lt; tree-&gt;key) // 应该将key插入到\"tree的左子树\"的情况 &#123; tree-&gt;left = insert(tree-&gt;left, key); // 插入节点后，若AVL树失去平衡，则进行相应的调节。 if (height(tree-&gt;left) - height(tree-&gt;right) == 2) &#123; if (key &lt; tree-&gt;left-&gt;key) tree = leftLeftRotation(tree); else tree = leftRightRotation(tree); &#125; &#125; else if (key &gt; tree-&gt;key) // 应该将key插入到\"tree的右子树\"的情况 &#123; tree-&gt;right = insert(tree-&gt;right, key); // 插入节点后，若AVL树失去平衡，则进行相应的调节。 if (height(tree-&gt;right) - height(tree-&gt;left) == 2) &#123; if (key &gt; tree-&gt;right-&gt;key) tree = rightRightRotation(tree); else tree = rightLeftRotation(tree); &#125; &#125; else //key == tree-&gt;key) &#123; cout &lt;&lt; \"添加失败：不允许添加相同的节点！\" &lt;&lt; endl; &#125; tree-&gt;height = max( height(tree-&gt;left), height(tree-&gt;right)) + 1; return tree;&#125;template &lt;class T&gt;void AVLTree&lt;T&gt;::insert(T key)&#123; insert(mRoot, key);&#125;/* * 删除结点(z)，返回根节点 * * 参数说明： * tree AVL树的根结点 * z 待删除的结点 * 返回值： * 根节点 */template &lt;class T&gt;AVLTreeNode&lt;T&gt;* AVLTree&lt;T&gt;::remove(AVLTreeNode&lt;T&gt;* &amp;tree, AVLTreeNode&lt;T&gt;* z)&#123; // 根为空 或者 没有要删除的节点，直接返回NULL。 if (tree==NULL || z==NULL) return NULL; if (z-&gt;key &lt; tree-&gt;key) // 待删除的节点在\"tree的左子树\"中 &#123; tree-&gt;left = remove(tree-&gt;left, z); // 删除节点后，若AVL树失去平衡，则进行相应的调节。 if (height(tree-&gt;right) - height(tree-&gt;left) == 2) &#123; AVLTreeNode&lt;T&gt; *r = tree-&gt;right; if (height(r-&gt;left) &gt; height(r-&gt;right)) tree = rightLeftRotation(tree); else tree = rightRightRotation(tree); &#125; &#125; else if (z-&gt;key &gt; tree-&gt;key)// 待删除的节点在\"tree的右子树\"中 &#123; tree-&gt;right = remove(tree-&gt;right, z); // 删除节点后，若AVL树失去平衡，则进行相应的调节。 if (height(tree-&gt;left) - height(tree-&gt;right) == 2) &#123; AVLTreeNode&lt;T&gt; *l = tree-&gt;left; if (height(l-&gt;right) &gt; height(l-&gt;left)) tree = leftRightRotation(tree); else tree = leftLeftRotation(tree); &#125; &#125; else // tree是对应要删除的节点。 &#123; // tree的左右孩子都非空 if ((tree-&gt;left!=NULL) &amp;&amp; (tree-&gt;right!=NULL)) &#123; if (height(tree-&gt;left) &gt; height(tree-&gt;right)) &#123; // 如果tree的左子树比右子树高； // 则(01)找出tree的左子树中的最大节点 // (02)将该最大节点的值赋值给tree。 // (03)删除该最大节点。 // 这类似于用\"tree的左子树中最大节点\"做\"tree\"的替身； // 采用这种方式的好处是：删除\"tree的左子树中最大节点\"之后，AVL树仍然是平衡的。 AVLTreeNode&lt;T&gt;* max = maximum(tree-&gt;left); tree-&gt;key = max-&gt;key; tree-&gt;left = remove(tree-&gt;left, max); &#125; else &#123; // 如果tree的左子树不比右子树高(即它们相等，或右子树比左子树高1) // 则(01)找出tree的右子树中的最小节点 // (02)将该最小节点的值赋值给tree。 // (03)删除该最小节点。 // 这类似于用\"tree的右子树中最小节点\"做\"tree\"的替身； // 采用这种方式的好处是：删除\"tree的右子树中最小节点\"之后，AVL树仍然是平衡的。 AVLTreeNode&lt;T&gt;* min = maximum(tree-&gt;right); tree-&gt;key = min-&gt;key; tree-&gt;right = remove(tree-&gt;right, min); &#125; &#125; else &#123; AVLTreeNode&lt;T&gt;* tmp = tree; tree = (tree-&gt;left!=NULL) ? tree-&gt;left : tree-&gt;right; delete tmp; &#125; &#125; return tree;&#125;template &lt;class T&gt;void AVLTree&lt;T&gt;::remove(T key)&#123; AVLTreeNode&lt;T&gt;* z; if ((z = search(mRoot, key)) != NULL) mRoot = remove(mRoot, z);&#125;/* * 销毁AVL树 */template &lt;class T&gt;void AVLTree&lt;T&gt;::destroy(AVLTreeNode&lt;T&gt;* &amp;tree)&#123; if (tree==NULL) return ; if (tree-&gt;left != NULL) destroy(tree-&gt;left); if (tree-&gt;right != NULL) destroy(tree-&gt;right); delete tree;&#125;template &lt;class T&gt;void AVLTree&lt;T&gt;::destroy()&#123; destroy(mRoot);&#125;/* * 打印\"二叉查找树\" * *key -- 节点的键值 *direction -- 0，表示该节点是根节点; * -1，表示该节点是它的父结点的左孩子; * 1，表示该节点是它的父结点的右孩子。 */template &lt;class T&gt;void AVLTree&lt;T&gt;::print(AVLTreeNode&lt;T&gt;* tree, T key, int direction)&#123; if(tree != NULL) &#123; if(direction==0) // tree是根节点 cout &lt;&lt; setw(2) &lt;&lt; tree-&gt;key &lt;&lt; \" is root\" &lt;&lt;\", height is \"&lt;&lt;tree-&gt;height&lt;&lt; endl; else // tree是分支节点 cout &lt;&lt; setw(2) &lt;&lt; tree-&gt;key &lt;&lt; \" is \" &lt;&lt; setw(2) &lt;&lt; key &lt;&lt; \"'s \" &lt;&lt; setw(12) &lt;&lt; (direction==1?\"right child\" : \"left child\") &lt;&lt;\", height is \"&lt;&lt;tree-&gt;height&lt;&lt; endl; print(tree-&gt;left, tree-&gt;key, -1); print(tree-&gt;right,tree-&gt;key, 1); &#125;&#125;template &lt;class T&gt;void AVLTree&lt;T&gt;::print()&#123; if (mRoot != NULL) print(mRoot, mRoot-&gt;key, 0);&#125; 测试文件 test.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include \"AVLTree.cpp\"using namespace std;static int arr[]= &#123;3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9&#125;;#define TBL_SIZE(a) ( (sizeof(a)) / (sizeof(a[0])) )int main()&#123; int i,ilen; AVLTree&lt;int&gt;* tree=new AVLTree&lt;int&gt;(); cout &lt;&lt; \"== 依次添加: \"; ilen = TBL_SIZE(arr); for(i=0; i&lt;ilen; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt;\" \"; tree-&gt;insert(arr[i]); &#125; cout &lt;&lt; \"\\n== 前序遍历: \"; tree-&gt;preOrder(); cout &lt;&lt; \"\\n== 中序遍历: \"; tree-&gt;inOrder(); cout &lt;&lt; \"\\n== 后序遍历: \"; tree-&gt;postOrder(); cout &lt;&lt; endl; cout &lt;&lt; \"== 高度: \" &lt;&lt; tree-&gt;height() &lt;&lt; endl; cout &lt;&lt; \"== 最小值: \" &lt;&lt; tree-&gt;minimum() &lt;&lt; endl; cout &lt;&lt; \"== 最大值: \" &lt;&lt; tree-&gt;maximum() &lt;&lt; endl; cout &lt;&lt; \"== 树的详细信息: \" &lt;&lt; endl; tree-&gt;print(); i = 8; cout &lt;&lt; \"\\n== 删除根节点: \" &lt;&lt; i; tree-&gt;remove(i); cout &lt;&lt; \"\\n== 高度: \" &lt;&lt; tree-&gt;height() ; cout &lt;&lt; \"\\n== 中序遍历: \" ; tree-&gt;inOrder(); cout &lt;&lt; \"\\n== 树的详细信息: \" &lt;&lt; endl; tree-&gt;print(); // 销毁二叉树 tree-&gt;destroy(); return 0;&#125;","categories":[{"name":"算法篇","slug":"算法篇","permalink":"https://cloudintheking.github.io/categories/算法篇/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://cloudintheking.github.io/tags/c/"},{"name":"数据结构","slug":"数据结构","permalink":"https://cloudintheking.github.io/tags/数据结构/"}]},{"title":"mongodb操作之$slice","slug":"mongodb操作之-slice","date":"2018-08-15T13:50:29.000Z","updated":"2021-04-26T13:07:09.982Z","comments":true,"path":"posts/9885f22a.html","link":"","permalink":"https://cloudintheking.github.io/posts/9885f22a.html","excerpt":"","text":"翻译原文：https://docs.mongodb.com/manual/reference/operator/update/slice/#examples $slice（切分）当进行$push(插入)操作时，可以通过 $slice修饰词来限制插入的数组元素个数。如果想从一个只读操作中映射或是返回数组元素中特定的值，详见$slice映射操作。$slice修饰词必须搭配$each修饰词才能使用。不过，你也可以传递一个空数组给$each修饰词，从而只让$slice修饰词起作用。12345678&#123; $push: &#123; &lt;field&gt;: &#123; $each: [ &lt;value1&gt;, &lt;value2&gt;, ... ], $slice: &lt;num&gt; &#125; &#125;&#125; &lt; num &gt; 的值可以是： Value Description 0 更新数组&lt;field&gt;为空数组 负数 更新数组&lt;field&gt;只包含最后&lt;num&gt;个元素 正数 更新数组&lt;field&gt;只包含开头&lt;num&gt;个元素，适用于2.6以上版本 Behavior(行为)这些修饰词出现的顺序是无关紧要的。不过在上一个版本中，要求$each修饰词得作为第一个修饰词出现，如果要和$slice修饰词连用的话。这里有一份关于和$push搭配使用的修饰词列表，详见Modifiers。不结合$each修饰词而只使用$slice修饰词将会导致出错，不信可以试试。 栗子从数组末尾切片一个学生集合包含以下文档：1&#123; \"_id\" : 1, \"scores\" : [ 40, 50, 60 ] &#125; 下面的操作增加一个新元素到scores数组中，然后使用$slice将数组修剪为最后五个元素。 1234567891011db.students.update( &#123; _id: 1 &#125;, &#123; $push: &#123; scores: &#123; $each: [ 80, 78, 86 ], $slice: -5 &#125; &#125; &#125;) 操作的结果就是将更新后的scores数组切分为最后5个元素1&#123; \"_id\" : 1, \"scores\" : [ 50, 60, 80, 78, 86 ] &#125; 从数组头部切片一个学生集合包含以下文档：1&#123; \"_id\" : 2, \"scores\" : [ 89, 90 ] &#125; 下面的操作增加一个新元素到scores数组中，然后使用$slice修饰词修剪为前三个元素。1234567891011db.students.update( &#123; _id: 2 &#125;, &#123; $push: &#123; scores: &#123; $each: [ 100, 20 ], $slice: 3 &#125; &#125; &#125;) 操作的结果就是将更新后的scores数组切分为前三个元素中。 只用slice来更新数组一个学生集合包含以下文档：1&#123; \"_id\" : 3, \"scores\" : [ 89, 70, 100, 20 ] &#125; 为了只用$slice修饰词来更新scores字段，我们得给出要切分的元素数量（比如 -3）赋给slice修饰词,而且赋一个空数组给$each修饰词，就像下面的代码：1234567891011db.students.update( &#123; _id: 3 &#125;, &#123; $push: &#123; scores: &#123; $each: [ ], $slice: -3 &#125; &#125; &#125;) 操作的结果就是将scores数组切分为最后三个元素。 slice 和push搭配使用一个学生集合包含以下文档：123456789&#123; \"_id\" : 5, \"quizzes\" : [ &#123; \"wk\": 1, \"score\" : 10 &#125;, &#123; \"wk\": 2, \"score\" : 8 &#125;, &#123; \"wk\": 3, \"score\" : 5 &#125;, &#123; \"wk\": 4, \"score\" : 6 &#125; ]&#125; 下面的$push操作将会： 使用$each修饰词来增加多个文档到quizzes数组中， 使用$sort修饰词，按照score字段来降序排序修改过的quizzies数组中的全部元素， 使用$slice修饰词，只保留quizzes数排中前三个排序过的元素。 123456789101112db.students.update( &#123; _id: 5 &#125;, &#123; $push: &#123; quizzes: &#123; $each: [ &#123; wk: 5, score: 8 &#125;, &#123; wk: 6, score: 7 &#125;, &#123; wk: 7, score: 6 &#125; ], $sort: &#123; score: -1 &#125;, $slice: 3 &#125; &#125; &#125;) 操作结果就是只保留了quizzes数组中分数最高的三个元素。12345678&#123; \"_id\" : 5, \"quizzes\" : [ &#123; \"wk\" : 1, \"score\" : 10 &#125;, &#123; \"wk\" : 2, \"score\" : 8 &#125;, &#123; \"wk\" : 5, \"score\" : 8 &#125; ]&#125; 上面操作中的修饰词都会被Mongodb自行处理，所有它们之间的书写顺序无关紧要。更多详情请见Modifiers。","categories":[{"name":"翻译篇","slug":"翻译篇","permalink":"https://cloudintheking.github.io/categories/翻译篇/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://cloudintheking.github.io/tags/mongodb/"}]},{"title":"oracle之表信息查询","slug":"oracle之表信息查询","date":"2018-08-10T13:41:43.000Z","updated":"2021-04-26T13:07:09.977Z","comments":true,"path":"posts/915a4669.html","link":"","permalink":"https://cloudintheking.github.io/posts/915a4669.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ 起因主管抽风，想查询数据库’dbo‘中各表字段结构、外键信息、索引信息。于是任务交给了我… 语句1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 各表字段结构SELECT TABLE_SCHEMA 数据库, table_name 表名, column_name 字段名, data_type 类型, is_nullable 是否为空, column_default 默认值FROM information_schema.columnsWHERE TABLE_SCHEMA = 'dbo'-- 各表外键信息SELECT object_name(parent_object_id) 表名, object_name(constraint_object_id) 约束名称, col_name(parent_object_id, parent_column_id) 外键字段, object_name(referenced_object_id) 关联表名, col_name(referenced_object_id, referenced_column_id) 关联表字段FROM sys.foreign_key_columnsWHERE referenced_object_id IN ( SELECT object_id(T.table_name) FROM ( SELECT table_name FROM information_schema.columns WHERE TABLE_SCHEMA = 'dbo' ) T)ORDER BY object_name(parent_object_id)-- 各表索引信息SELECT object_name(object_id) 表名, name 索引名, is_unique 是否唯一FROM sys.indexesWHERE Object_id IN ( SELECT object_id(T.table_name) FROM ( SELECT table_name FROM information_schema.columns WHERE TABLE_SCHEMA = 'dbo' ) T)ORDER BY 表名","categories":[{"name":"数据库","slug":"数据库","permalink":"https://cloudintheking.github.io/categories/数据库/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://cloudintheking.github.io/tags/sql/"}]},{"title":"oracle之多表统计查询","slug":"oracle之多表统计查询","date":"2018-08-09T13:58:40.000Z","updated":"2021-04-26T13:07:09.977Z","comments":true,"path":"posts/771d835a.html","link":"","permalink":"https://cloudintheking.github.io/posts/771d835a.html","excerpt":"","text":"起因主管想根据时间范围统计下各标段各桥梁部件的录入数量，这个任务就交给我吧… 表介绍 qr_code_item_type：桥梁部件类型表，类型有桩基、承台、墩柱等 qr_code_item1 ：桥梁墩柱类部件信息表，关联表qr_code_item_type、qr_code_main qr_code_item2 ：桥梁梁类部件信息表，关联表qr_code_item_type、qr_code_main qr_code_main：桥梁标段表语句1234567891011121314151617SELECT itype.id,isnull(total, 0) totalFROM qr_code_item_type itype LEFT JOIN ( SELECT item.item_type_id type,COUNT(*) total FROM qr_code_item item LEFT JOIN qr_code_main main ON item.qr_code_main_id = main.id WHERE main.section = 2 AND isnull(item.update_time, item.create_time) BETWEEN '20180301' AND '20180801' GROUP BY item.item_type_id UNION ALL SELECT item.item_type_id type, COUNT(*) total FROM qr_code_item2 item LEFT JOIN qr_code_main main ON item.qr_code_main_id = main.id WHERE main.section = 2 AND isnull(item.update_time, item.create_time) BETWEEN '20180301' AND '20180801' GROUP BY item.item_type_id ) aa ON itype.id = aa.typeORDER BY itype.id ps:墩柱类、梁类虽都属于部件类，但具体信息差别较大，故分成两个表，所以统计的时候使用了联合查询","categories":[{"name":"数据库","slug":"数据库","permalink":"https://cloudintheking.github.io/categories/数据库/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://cloudintheking.github.io/tags/sql/"}]},{"title":"mongodb之主从、集群、分片","slug":"mongodb之主从、集群、分片","date":"2018-08-07T14:04:05.000Z","updated":"2021-04-26T13:07:09.970Z","comments":true,"path":"posts/14f7ff4b.html","link":"","permalink":"https://cloudintheking.github.io/posts/14f7ff4b.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ 核心语句博客也好，官网也罢，密密麻麻一堆话，提炼浓缩就下面这几行命令12345678910111213141516171819202122#主从复制mongod --port 27018 --dbpath \"F:\\mongodbSet\\mongodb1\\data\" --logpath \"F:\\mongodbSet\\mongodb1\\log\\mongodb.log\" --logappend --mastermongod --port 27019 --dbpath \"F:\\mongodbSet\\mongodb2\\data\" --logpath \"F:\\mongodbSet\\mongodb2\\log\\mongodb.log\" --logappend --slave --source=127.0.0.1:27018#副本集mongod --port 27018 --dbpath \"F:\\mongodbSet\\mongodb1\\data\" --logpath \"F:\\mongodbSet\\mongodb1\\log\\mongodb.log\" --logappend --replSet myrsmongod --port 27019 --dbpath \"F:\\mongodbSet\\mongodb2\\data\" --logpath \"F:\\mongodbSet\\mongodb2\\log\\mongodb.log\" --logappend --replSet myrsmongod --port 27020 --dbpath \"F:\\mongodbSet\\mongodb3\\data\" --logpath \"F:\\mongodbSet\\mongodb3\\log\\mongodb.log\" --logappend --replSet myrs#分片+副本集#configmongod --port 27018 --bind_ip 127.0.0.1 --configsvr --dbpath \"F:\\mongodbSet\\config\\mongodb1\\data\" --logpath \"F:\\mongodbSet\\config\\mongodb1\\log\\mongodb.log\" --logappend --replSet configsmongod --port 27019 --bind_ip 127.0.0.1 --configsvr --dbpath \"F:\\mongodbSet\\config\\mongodb2\\data\" --logpath \"F:\\mongodbSet\\config\\mongodb2\\log\\mongodb.log\" --logappend --replSet configsmongod --port 27020 --bind_ip 127.0.0.1 --configsvr --dbpath \"F:\\mongodbSet\\config\\mongodb3\\data\" --logpath \"F:\\mongodbSet\\config\\mongodb3\\log\\mongodb.log\" --logappend --replSet configs#shardmongod --port 27024 --bind_ip 127.0.0.1 --shardsvr --dbpath \"F:\\mongodbSet\\shared\\mongodb1\\data\" --logpath \"F:\\mongodbSet\\shared\\mongodb1\\log\\mongodb.log\" --logappend --replSet shardmongod --port 27025 --bind_ip 127.0.0.1 --shardsvr --dbpath \"F:\\mongodbSet\\shared\\mongodb2\\data\" --logpath \"F:\\mongodbSet\\shared\\mongodb2\\log\\mongodb.log\" --logappend --replSet shardmongod --port 27026 --bind_ip 127.0.0.1 --shardsvr --dbpath \"F:\\mongodbSet\\shared\\mongodb3\\data\" --logpath \"F:\\mongodbSet\\shared\\mongodb3\\log\\mongodb.log\" --logappend --replSet shard#mongosmongos --port 27021 --configdb configs/127.0.0.1:27018,127.0.0.1:27019,127.0.0.1:27020 --replSet mongos 相关命令解释 –port &lt;端口号&gt;： 设置mongo服务开启的端口 –dbpath &lt;数据存储路径&gt;：设置mongo数据存储路径 –logpath &lt;日志存储路径&gt;：设置mongo日志存储路径 –logappend ：启用日志追加方式，否则新日志会覆盖旧日志 –master ：设置为master方 –slave：设置为slave方 –source = &lt; ip : port&gt;：设置master服务的地址 –replSet &lt;集群名&gt;：设置集群名称","categories":[{"name":"数据库","slug":"数据库","permalink":"https://cloudintheking.github.io/categories/数据库/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://cloudintheking.github.io/tags/mongodb/"}]},{"title":"我的装备清单","slug":"我的装备清单","date":"2018-08-06T06:45:42.000Z","updated":"2021-04-26T13:07:09.970Z","comments":true,"path":"posts/6059b33.html","link":"","permalink":"https://cloudintheking.github.io/posts/6059b33.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ why?随着技术栈的加深，认识的语言和工具也越来越多，若是整理出一份清单，重装环境的时候想想头就大... 开发环境 Maven DosBox Git Python Node.js Java nginx nvm masm32 开发工具 IDE IntelliJ IDEA PyCharm WebStorm Visual C++6.0 密码:ec13 反编译神器 Bytecode Viewer 数据可视化工具 DataGrip Redis Desktop Manager NoSQL Manager 虚拟机 vmware 密码：t8i3 容器 Docker git管理工具 小乌龟 终端连接工具 xshell 远程桌面工具 TeamViewer 下载神器 IDM 转码神器 FFmpeg 科学上网 shadowsocksR 密码：0w5g 其他 印象笔记 马克飞象 微信 Chrome(需翻墙) 火绒(比360良心100倍) 百度网盘 7-zip Postman(restfulsapi 调试神器 )","categories":[{"name":"环境安装篇","slug":"环境安装篇","permalink":"https://cloudintheking.github.io/categories/环境安装篇/"}],"tags":[{"name":"清单","slug":"清单","permalink":"https://cloudintheking.github.io/tags/清单/"}]},{"title":"Flex-Layout之声明式API概述","slug":"Flex-Layout之声明式API概述","date":"2018-08-04T13:24:09.000Z","updated":"2021-04-26T13:07:09.965Z","comments":true,"path":"posts/50688eb0.html","link":"","permalink":"https://cloudintheking.github.io/posts/50688eb0.html","excerpt":"","text":"翻译原文：https://github.com/angular/flex-layout/wiki/Declarative-API-Overview 静态API概述Flex layout 的特点就是提供敏捷的语法性的指令允许开发者利用弹性盒子CSS样式来轻松直观地创建响应且自适应的布局。 这个API概述可以被视作静态的，提供一个随浏览器宽度改变而调整元素的大小和位置的用户体验。这个静态API可以被视为默认桌面布局API。开发者应该使用响应式API来支持手机或平板设备的交互式布局配置。 Flex-Layout 是一组直观的HTML指令（aka属性）列表，可以被用于HTML容器和元素。开发者可以直接在HTML中定义他们自己的布局声明。一个重要的基本的概念就是理解哪些API被用在DOM容器上，哪些被用在DOM容器的子元素上。 用于DOM容器的API： HTML API Allowed values fxLayout &lt; direction &gt; [wrap] row / column / row-reverse / column-reverase fxLayoutAlign &lt; main-axis &gt; &lt; cross-axis&gt; main-axis: start / center / end / space-around / space-between; cross-axis: start / center / end / stretch fxLayoutGap % / px / vw / vh 这些指令会影响容器中子元素的流向和布局。 用于DOM元素的API： HTML Allowed values fxFlex “” / px / % / vw / vh &lt; grow&gt; &lt; shrink&gt; &lt; basis&gt; fxFlexOrder int fxFlexOffset % / px / vw / vh fxFlexAligin start / baseline / center / end fxFlexFill,fxFill 这些指令影响宿主元素的布局和大小。注意这些API期望它们的宿主元素内置于一个弹性盒子的DOM容器里（一个块元素，它本身使用布局API来作为容器）。 用于任意元素的API ： HTML API Allowed values fxHide TRUE / FALSE / 0 / “” fxShow TRUE / FALSE / 0 / “” ngClass @extends ngClass core ngStyle @extends ngStyle core imgSrc @extends src attribute 下面展示的是使用容器和元素的静态API来写的一个简单的HTML标记：123456789&lt;div fxLayout='column' class=\"zero\"&gt; &lt;div fxFlex=\"33\" class=\"one\" &gt;&lt;/div&gt; &lt;div fxFlex=\"33%\" [fxLayout]=\"direction\" class=\"two\"&gt; &lt;div fxFlex=\"22%\" class=\"two_one\"&gt;&lt;/div&gt; &lt;div fxFlex=\"205px\" class=\"two_two\"&gt;&lt;/div&gt; &lt;div fxFlex=\"30\" class=\"two_three\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div fxFlex class=\"three\"&gt;&lt;/div&gt;&lt;/div&gt; Flex Layout指令直接分配CSS样式内嵌到宿主元素中，这些内嵌样式会覆盖掉继承的样式、影子DOM样式，甚至是所有基于:host元素的影子DOM树形样式。 响应式APIFlex-Layout 也拥有一套巨大的响应特征来确保开发者能够轻松地改变不同显示设备之间的用户体验布局配置。更多文档资料请至 Responsive API page。 本文仅作翻译，关于弹性布局框架的相关知识，推荐博文。后期我会抽空翻译Flex-Layout的其他文章。","categories":[{"name":"翻译篇","slug":"翻译篇","permalink":"https://cloudintheking.github.io/categories/翻译篇/"}],"tags":[{"name":"flex-layout","slug":"flex-layout","permalink":"https://cloudintheking.github.io/tags/flex-layout/"}]},{"title":"Nginx之正反向代理","slug":"Nginx之正反向代理","date":"2018-08-02T14:01:08.000Z","updated":"2021-04-26T13:07:09.956Z","comments":true,"path":"posts/a174bf32.html","link":"","permalink":"https://cloudintheking.github.io/posts/a174bf32.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ 前言科学上网过的小伙伴们都知道，目前这些上网工具SS、SSR、V2Ray等等，说白了就是通过代理让我们得以愉快地遨游在知识的海洋里。 正向代理概念正向代理是什么？由于某些网站访问奇慢，或者墙的问题根本无法访问时，通过给浏览器配置代理ip和端口，让代理服务器转发我们请求，而后将响应结果传回浏览器，这就是正向代理。举个通俗的栗子，就好比你自己没找到合适的房子，于是你通过房租中介来租到好房子。大致流程如下： nginx正向代理主要配置服务端在虚拟机上部署了一台nginx服务器（有独立局域网ip）12345678server &#123; resolver 114.114.114.114 8.8.8.8; #指定DNS服务器IP地址 listen 8888; #监听端口 location / &#123; proxy_pass $scheme://$host$request_uri; #设定代理服务器的协议和地址 proxy_set_header Host $http_host; &#125; &#125; 然后重启nginx生效 客户端打开Chrome浏览器-&gt;设置-&gt;高级-&gt;系统-&gt;打开代理设置，如图所示： 其中，192.168.1.44就是你新建虚拟机的独立局域网IP。 反向代理概念你可以这么理解，正向代理服务器只是转发代理请求，并不提供自己的服务；而反向代理可以提供自己的服务。比如说，有个请求想要访问你公司内网服务器，而实际公司只有一个公共IP，内网IP并没有映射，所以这时候你就可以使用nginx反向代理来实现内网资源的请求。另外，如果访问量过大，还可以使用nginx来进行负载均衡。大致流程如下： nginx反向代理主要配置1234567891011121314151617181920212223242526upstream clusterserver &#123; #不设置，则默认是轮询 #least_conn; #最少连接数 #ip_hash; #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 server 192.1.168.45:9991 weight=1; #weight值为1~10，代表权重，和访问比率成正比，用于后端服务器性能不均的情况 server 192.1.168.46:9991 weight=1; #server 192.1.168.45:9993 weight=1 down; #手工设置该服务不可用 #server 192.1.168.45:9994 weight=1 backup; #其他主服务器都挂了，自动开启这个备用服务。&#125; server &#123; listen 9999; server_name xxx; #你的域名或者公共IP location / &#123; root html; index index.html index.htm; proxy_pass http://clusterserver; proxy_connect_timeout 1; #单位为秒 超时设置，如果超时将请求其他服务 #proxy_send_timeout 1; #proxy_read_timeout 1; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 这样当代理服务器监听到9999端口的请求时，根据proxy_pass配置找到名为clusterserver的upstream 节点来进行负载均衡。","categories":[{"name":"后端笔记","slug":"后端笔记","permalink":"https://cloudintheking.github.io/categories/后端笔记/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://cloudintheking.github.io/tags/nginx/"}]},{"title":"powershell之启动远程jar服务","slug":"powershell之启动远程jar服务","date":"2018-07-29T13:20:21.000Z","updated":"2021-04-26T13:07:09.965Z","comments":true,"path":"posts/3edeb9a.html","link":"","permalink":"https://cloudintheking.github.io/posts/3edeb9a.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ 起因主管抽风说每次都要登录远程服务器再启动jar太麻烦了，要是有个一键启动远程jar的批处理就是。于是这个任务就交给我了… powershell配置用管理员权限启动 PowerShell,执行下面的命令:123456789101112131415161718#客户端或服务器公共配置:Get-Service WinRM #查看WinRM服务的状态Enable-PSRemoting –Force #配置系统接受远程命令Set-Service WinRM -StartMode Automatic #开启WinRM服务自启动winrm set winrm/config/winrs '@&#123;MaxMemoryPerShellMB=\"3000\"&#125;' #设置powershell最大内存 方法一推荐Set-Item WSMan:\\localhost\\Plugin\\Microsoft.PowerShell\\Quotas\\MaxMemoryPerShellMB 3000 #设置最大内存 方法二Restart-Service winrm //重启winrm服务使配置生效#服务器配置:Set-Item WSMan:localhost\\client\\trustedhosts -value \"192.168.1.44,192.168.1.45\" #设置设置主机可信任的客户端地址winrm set winrm/config/client @&#123;TrustedHosts=\"192.168.1.45,192.168.1.44\"&#125; #设置设置主机可信任的客户端地址，当上个命令无效时，可选用该命令（该命令请在cmd中使用） Get-Item WSMan:\\localhost\\Client\\TrustedHosts #查看可信任主机get-executionpolicy #查看脚本执行策略set-executionpolicy remotesigned #设置执行策略为远程可执行Restart-Service winrm #重启服务生效Test-WsMan xxx.xxx.xxx.xxx #客户端测试远程连接 jar包上传处理命令 服务器上必须安装了ftp,否则没法上传文件。我公司服务器系统是windows server 2008,用它自带的IIS创建ftp,并设置虚拟目录。 新建上传文件脚本up.bat：123456789101112131415161718curl -X POST 192.168.1.44:8886/shutdown #关闭44服务器上8886端口服务curl -X POST 192.168.1.44:8887/shutdown#关闭44服务器上8887端口服务curl -X POST 192.168.1.44:8888/shutdown#关闭44服务器上8888端口服务Echo open 192.168.1.44 &gt;ftp.up #打开连接44服务器ftp连接Echo Administrator&gt;&gt;ftp.up #服务器上登录用户名Echo 59@SDS25&gt;&gt;ftp.up #登录密码Echo cd .\\project1&gt;&gt;ftp.up #因为进入的是ftp的根目录，所以使用.\\project1,进入根目录下的project1Echo binary&gt;&gt;ftp.up #二进制数据传输格式Echo put \"E:\\Workspace\\idea\\jcnyJava\\target\\jcny-java-0.0.1-SNAPSHOT.jar\"&gt;&gt;ftp.up #传送本地文件到ftp中Echo cd ..\\project2&gt;&gt;ftp.up #使用..\\project2,进入根目录下的project2目录Echo put \"E:\\Workspace\\idea\\jcnyJava\\target\\jcny-java-0.0.1-SNAPSHOT.jar.original\"&gt;&gt;ftp.up #传送本地文件到ftp中Echo cd ..\\project3&gt;&gt;ftp.up #进入根目录下的project3目录Echo put \"E:\\Workspace\\idea\\jcnyJava\\target\\jcny-java-0.0.1-SNAPSHOT.jar.original\"&gt;&gt;ftp.up #传送本地文件到ftp中Echo bye&gt;&gt;ftp.up #客户端关闭ftp连接FTP -s:ftp.up #服务器关闭ftp连接del ftp.up /q #删除ftp连接Pause powershell启动远程服务命令新建一个启动脚本deploy.ps112345678$na = \"yourname\" #服务器用户名 $p2 = ConvertTo-SecureString \"yourpassword\" -AsPlainText -Force #加密登录密码 $A = New-Object System.Management.Automation.PSCredential($na,$p2) #创建连接Invoke-Command -ComputerName 192.168.1.44 -Credential $A -ScriptBlock &#123; #执行远程操作Set-Location E:\\webroot\\projects #进入远程服务器目录invoke-expression -command E:\\webroot\\tongtu-projects\\startall.bat #远程服务启动的脚本路径&#125; 以上命令都是针对Windows系统的，Linux系统应该是写bash脚本吧。如果下次主管说要一键启动远程Linux上的服务的话，到时候我再写篇linux的吧。","categories":[{"name":"后端笔记","slug":"后端笔记","permalink":"https://cloudintheking.github.io/categories/后端笔记/"}],"tags":[{"name":"powershell","slug":"powershell","permalink":"https://cloudintheking.github.io/tags/powershell/"}]},{"title":"Python虚拟环境搭建","slug":"Python虚拟环境搭建","date":"2018-07-26T06:36:54.000Z","updated":"2021-04-26T13:07:09.956Z","comments":true,"path":"posts/7a79fcd9.html","link":"","permalink":"https://cloudintheking.github.io/posts/7a79fcd9.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ 应用场景搭建 Python 虚拟环境，可以方便地Python2，Python3 共存。避免包的混乱和版本的冲突。为每个应用程序单独创建虚拟环境可以保证程序中能访问虚拟环境中的包，保持解释器环境的干净整洁。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。 我的开发环境 windows 10 python2.7 python3.5 安装使用 virtualenv前言因为我装了python2.7、3.5，所以也就有了两个pip包管理工具，默认会使用高版本python的pip，but也可以指定s使用哪个Python版本的pip，如pip2指定使用Python2.7的pip。 安装1pip3 install virtualenv 创建虚拟环境12cd your_project_dir #进入你的工程目录virtualenv env1 -p G:\\Environment\\Python\\Python27 --no-site-packages env1：虚拟环境目录名 -p：指定Python安装路径 –no-site-packages： 不复制系统Python环境中的所有第三方包 这样我们就得到了一个不带任何第三方包的“干净”的Python2.7运行环境。 激活虚拟环境cd env1 #进入虚拟环境 cd Scirpts #进入脚本目录 activate #激活虚拟环境 deactivate #退出虚拟环境 截图如下： 当执行activate时，注意命令提示符变了，有个(env1)前缀，表示当前环境是一个名为env1的Python环境。 虽然virtualenv很强大，但仍有不足。你想，要是以后创建的虚拟环境多了，它们分散在系统各处，时间一长，你可能忘记它们的名字或者位置。所以下面介绍virtualenvwrapper。 安装使用 virtualenvwrapper介绍virtualenvwrapper 是对 virtualenv 的功能扩展，可以管理全部的虚拟环境，用单个命令方便切换不同的虚拟环境。 安装pip install virtualenvwrapper-win 设置workon_home环境变量 基本命令新建虚拟环境如果不指定Python解释器程序路径，则会默认使用系统里高版本Python1mkvirtualenv env2 mkvirtualenv –python=(pytho执行路径) (虚拟环境名字)1mkvirtualenv --python=G:\\Environment\\Python\\Python27\\python.exe mypython27 查看安装的所有虚拟环境workon 进入和退出虚拟环境12workon mypython27deactivate 其他1mkvirtualenv -h #更多命令大家自己探索吧 后记创建python虚拟环境的技术不只有virtualenv，现在最新的是pyenv技术，这也是官方推荐使用的，后期有时间再专门写篇吧另外 pycham这个IDE自带了Python虚拟环境创建功能，jetbrains系列就是","categories":[{"name":"环境安装篇","slug":"环境安装篇","permalink":"https://cloudintheking.github.io/categories/环境安装篇/"}],"tags":[{"name":"python","slug":"python","permalink":"https://cloudintheking.github.io/tags/python/"}]},{"title":"二叉查找树之C++实现","slug":"二叉查找树之C-实现","date":"2018-07-20T13:53:56.000Z","updated":"2021-04-26T13:07:09.970Z","comments":true,"path":"posts/d482e59b.html","link":"","permalink":"https://cloudintheking.github.io/posts/d482e59b.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;template&lt;class T&gt;struct BSTreeNode&#123; T key; BSTreeNode *left; BSTreeNode *right; BSTreeNode *parent; BSTreeNode(T k )&#123; key=k; left=NULL; right=NULL; parent=NULL; &#125; BSTreeNode()&#123;&#125;;&#125;;//错误信息 struct ErrorMessage&#123; bool flag; string message; &#125;; //生成节点并插入树中template&lt;class T&gt;ErrorMessage insert(BSTreeNode&lt;T&gt;* &amp;root,T key)&#123; BSTreeNode&lt;T&gt;* node=NULL; ErrorMessage error; stringstream s; if ((node=new BSTreeNode&lt;T&gt;(key)) == NULL) &#123; s&lt;&lt;\"值\"&lt;&lt;key&lt;&lt;\"分配节点内存失败\"; error.flag=false; error.message= s.str(); return error; &#125; BSTreeNode&lt;T&gt;* x= root; BSTreeNode&lt;T&gt;* y= NULL; while (x !=NULL) &#123; y=x; if (node-&gt;key&lt;x-&gt;key) &#123; x=x-&gt;left; &#125; else if(node-&gt;key&gt;x-&gt;key)&#123; x=x-&gt;right; &#125; else&#123; s&lt;&lt;\"值\"&lt;&lt;key&lt;&lt;\"重复,创建节点失败\"; error.flag=false; error.message=s.str(); return error; &#125; &#125; node-&gt;parent=y; if (y==NULL) &#123; root = node; &#125; else if(node-&gt;key&lt;y-&gt;key)&#123; y-&gt;left=node; &#125; else&#123; y-&gt;right=node; &#125; s&lt;&lt;\"值\"&lt;&lt;key&lt;&lt;\"创建节点成功\"; error.flag=true; error.message=s.str(); return error;&#125;//前序遍历template&lt;class T &gt;void preShow(BSTreeNode&lt;T&gt;* node)&#123; if (node != NULL) &#123; cout&lt;&lt;node-&gt;key&lt;&lt;\" \"; preShow(node-&gt;left); preShow(node-&gt;right); &#125;&#125;//中序遍历template&lt;class T&gt;void midShow(BSTreeNode&lt;T&gt;* node)&#123; if (node !=NULL) &#123; midShow(node-&gt;left); cout&lt;&lt;node-&gt;key&lt;&lt;\" \"; midShow(node-&gt;right); &#125;&#125;//后序遍历template&lt;class T &gt;void postShow(BSTreeNode&lt;T&gt;* node)&#123; if (node != NULL) &#123; cout&lt;&lt;node-&gt;key&lt;&lt;\" \"; postShow(node-&gt;left); postShow(node-&gt;right); &#125;&#125;// 查找节点树下包含key的节点template&lt;class T &gt;BSTreeNode&lt;T&gt;* search(BSTreeNode&lt;T&gt;* node,T key)&#123; if (node == NULL || node-&gt;key == key) &#123; return node; &#125; else &#123; if (node-&gt;key&gt;key) &#123; search(node-&gt;left,key); &#125; else if (node-&gt;key&lt;key) &#123; search(node-&gt;right,key); &#125; &#125;&#125;// 返回节点树中最大值的节点template&lt;class T &gt;BSTreeNode&lt;T&gt;* maxNode(BSTreeNode&lt;T&gt;* node)&#123; if (node==NULL) &#123; return NULL; &#125; if (node-&gt;right==NULL) &#123; return node; &#125; else &#123; maxNode(node-&gt;right); &#125;&#125;// 返回节点树中最小值的节点template&lt;class T &gt;BSTreeNode&lt;T&gt;* minNode(BSTreeNode&lt;T&gt;* node)&#123; if (node==NULL) &#123; return NULL; &#125; if (node-&gt;left==NULL) &#123; return node; &#125; else &#123; minNode(node-&gt;left); &#125;&#125;//返回传入节点的后继节点template&lt;class T&gt;BSTreeNode&lt;T&gt;* successor(BSTreeNode&lt;T&gt;* node)&#123; if(node == NULL)&#123; return NULL; &#125; if (node-&gt;right!=NULL) &#123; return minNode(node-&gt;right); &#125; BSTreeNode&lt;T&gt;* parent=node-&gt;parent; BSTreeNode&lt;T&gt;* child=node; while(parent!=NULL&amp;&amp;parent-&gt;left!=child)&#123; child=parent; parent=parent-&gt;parent; &#125; return parent;&#125;// 返回传入节点的前驱节点template&lt;class T&gt;BSTreeNode&lt;T&gt;* predecessor(BSTreeNode&lt;T&gt;* node)&#123; if (node == NULL) &#123; return NULL; &#125; if (node-&gt;left!=NULL) &#123; return maxNode(node-&gt;left); &#125; BSTreeNode&lt;T&gt;* parent=node-&gt;parent; BSTreeNode&lt;T&gt;* child=node; while(parent!=NULL&amp;&amp;parent-&gt;right!=child)&#123; child=parent; parent=parent-&gt;parent; &#125; return parent;&#125;//删除节点template&lt;class T&gt;void delete_node(BSTreeNode&lt;T&gt;* &amp;root, BSTreeNode&lt;T&gt;* node)&#123; if (node-&gt;left==NULL&amp;&amp;node-&gt;right==NULL) //叶子节点 &#123; if (node == root) &#123; root=NULL; &#125; else if (isLeft(node)) &#123; node-&gt;parent-&gt;left=NULL; &#125; else&#123; node-&gt;parent-&gt;right=NULL; &#125; &#125; else if (node-&gt;left==NULL) //只有右子节点 &#123; if (node == root) //节点是根节点 &#123; root=node-&gt;right; node-&gt;right-&gt;parent=NULL; &#125; else if (isLeft(node)) //节点是左节点 &#123; node-&gt;parent-&gt;left=node-&gt;right; node-&gt;right-&gt;parent=node-&gt;parent; &#125; else&#123; //节点是右节点 node-&gt;parent-&gt;right=node-&gt;right; node-&gt;right-&gt;parent=node-&gt;parent; &#125; &#125; else if (node-&gt;right==NULL) //只有左节点 &#123; if (node == root) //节点是根节点 &#123; root=node-&gt;left; node-&gt;left-&gt;parent=NULL; &#125; else if (isLeft(node)) //节点是左节点 &#123; node-&gt;parent-&gt;left=node-&gt;left; node-&gt;left-&gt;parent=node-&gt;parent; &#125; else&#123; //节点是右节点 node-&gt;parent-&gt;right=node-&gt;left; node-&gt;left-&gt;parent=node-&gt;parent; &#125; &#125; else //左右节点都有 &#123; BSTreeNode&lt;T&gt;* suc= successor(node); //node 的后继节点 if (suc == node-&gt;right) //后继节点为右子节点 &#123; if (node == root)// 删除节点为根节点 &#123; root=suc; suc-&gt;left=node-&gt;left; node-&gt;left-&gt;parent=suc; &#125; else&#123;// 删除节点不为根节点 if (isLeft(node)) //删除节点为左节点 &#123; node-&gt;parent-&gt;left= suc; &#125; else&#123; // 删除节点为右节点 node-&gt;parent-&gt;right=suc; &#125; suc-&gt;parent=node-&gt;parent; suc-&gt;left=node-&gt;left; node-&gt;left-&gt;parent=suc; &#125; &#125; else //后继节点不为右子节点 &#123; suc-&gt;parent-&gt;left=suc-&gt;right; if (suc-&gt;right!=NULL) // 后继节点的右节点不空 &#123; suc-&gt;right-&gt;parent= suc-&gt;parent; &#125; suc-&gt;left =node-&gt;left; node-&gt;left-&gt;parent =suc; suc-&gt;right=node-&gt;right; node-&gt;right-&gt;parent =suc; suc-&gt;parent=node-&gt;parent; if (node==root) &#123; root=suc; &#125; &#125; &#125; delete node; node=NULL;&#125;template&lt;class T&gt;bool deleteByKey(BSTreeNode&lt;T&gt;* &amp;root, T key)&#123; BSTreeNode&lt;T&gt;* node= search(root,key); if (node == NULL) &#123; return false; &#125; else&#123; delete_node(root,node); return true; &#125;&#125;// 判断是否为左节点template&lt;class T&gt;bool isLeft(BSTreeNode&lt;T&gt;* node)&#123; if (node-&gt;parent!=NULL&amp;&amp;node-&gt;parent-&gt;left==node) &#123; return true; &#125; return false;&#125;int main()&#123; BSTreeNode&lt;int&gt;* root=NULL; cout&lt;&lt;insert(root,5).message&lt;&lt;endl; cout&lt;&lt;insert(root,3).message&lt;&lt;endl; cout&lt;&lt;insert(root,1).message&lt;&lt;endl; cout&lt;&lt;insert(root,2).message&lt;&lt;endl; cout&lt;&lt;\"前序\"&lt;&lt;endl; preShow(root); cout&lt;&lt;endl&lt;&lt;\"中序\"&lt;&lt;endl; midShow(root); cout&lt;&lt;endl&lt;&lt;\"后序\"&lt;&lt;endl; postShow(root); cout&lt;&lt;endl; if (search(root,4) != NULL) &#123; cout&lt;&lt;\"存在\"&lt;&lt;4&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;\"不存在\"&lt;&lt;4&lt;&lt;endl; &#125; cout&lt;&lt;\"最大值:\"&lt;&lt;maxNode(root)-&gt;key&lt;&lt;endl; cout&lt;&lt;\"最小值:\"&lt;&lt;minNode(root)-&gt;key&lt;&lt;endl; cout&lt;&lt;\"3的后继:\"&lt;&lt;successor(search(root,3))-&gt;key&lt;&lt;endl; cout&lt;&lt;\"3的前驱:\"&lt;&lt;predecessor(search(root,3))-&gt;key&lt;&lt;endl; if ( deleteByKey(root,5)) &#123; cout&lt;&lt;\"5删除成功\"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\"5删除成功\"&lt;&lt;endl; &#125; cout&lt;&lt;\"中序\"&lt;&lt;endl; midShow(root); return 0;&#125;","categories":[{"name":"算法篇","slug":"算法篇","permalink":"https://cloudintheking.github.io/categories/算法篇/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://cloudintheking.github.io/tags/c/"},{"name":"数据结构","slug":"数据结构","permalink":"https://cloudintheking.github.io/tags/数据结构/"}]},{"title":"npm 升级失败解决方案","slug":"npm-升级失败解决方案","date":"2018-07-14T04:44:37.000Z","updated":"2021-04-26T13:07:09.956Z","comments":true,"path":"posts/ada9fa1e.html","link":"","permalink":"https://cloudintheking.github.io/posts/ada9fa1e.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ 说一下我的开发环境： Windows 10 node 8.10.0 nvm 1.1.6 npm这个东东其实也不会经常去升级它，但因为要安装angular cli,提示我npm版本低了得升级，这才去升级，哪晓得一个简单npm升级居然就炸了。 error:1npm ERR! path C:\\Program Files\\nodejs\\npm.cmd npm ERR! code EEXIST npm ERR! Refusing to delete C:\\Program Files\\nodejs\\npm.cmd: is outside C:\\Program Files\\nodejs\\node_modules\\npm and not a link npm ERR! File exists: C:\\Program Files\\nodejs\\npm.cmd npm ERR! Move it away, and try again. 提示我移除C:\\Program Files\\nodejs\\npm.cmd这个文件，可这个文件不是npm的命令文件吗，把这移除了，那我命令行里敲npm xxx什么的不都执行不了吗？算了，先按提示来吗，我移除了npm.cmd，嗯，这下好了，npm -v 都报错了。 百度了半天也没找到类似的错误，最后没办法，只好使出那一招了，大科学上网术！（翻墙谷歌） 很快就找到类似的错误了，给我激动的哇 issues 至于为啥会报这种错，我琢磨着可能是因为我从npm5.x.x升级到6.x.x，跨了一个大版本的原因吧，后来从npm6.1.0正常升到6.3.0就没报错了 解决方案如下： 首先将你nodejs安装目录下的 node_modules/npm文件夹 复制到任意路径下 再将nodejs安装目录下的npm.bin、npm.cmd删了 最后进入第一步复制的xxx/npm/bin目录下，执行node npm-cli.js i -g npm@latest 命令，欧了！ 我是真滴佩服想出这个办法的仁兄，高，太高了","categories":[{"name":"问题总结篇","slug":"问题总结篇","permalink":"https://cloudintheking.github.io/categories/问题总结篇/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://cloudintheking.github.io/tags/nodejs/"}]},{"title":"windows下安装nvm及nrm","slug":"windows下安装nvm及nrm","date":"2018-07-12T01:14:12.000Z","updated":"2021-04-26T13:07:09.948Z","comments":true,"path":"posts/c4e70f88.html","link":"","permalink":"https://cloudintheking.github.io/posts/c4e70f88.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ nvmnvm是什么以及应用场景基于node的项目对node版本依赖是不同的，而电脑上只安装了一个node的版本，那显然是不够的。所以nvm（Node Version Manager），一个node版本管理工具就诞生了。它就就像是一个开关，切换系统里不同的node版本，切记同一时刻有且只有一个node版本生效，node8和node10不能同时存在。 安装如果你已经装了node了，建议完全卸载了（连同npm，还有环境变量）,如果不卸载的话可能会和nvm发生冲突 下载地址 它有两个版本 nvm-noinstall.zip(免安装) 、nvm-setup.zip(图形界面安装GUI)，它们两个区别只在于免安装需要自己手动配置环境变量而GUI版给你自动配好了，下面基于GUI版简单说明一下： 当你安装到这一步时，选择nvm的安装目录，我这里是：D:\\Environment\\nvm 这一步是设置创建一个链接目录指向真正的node的安装目录，我这里是：D:\\Environment\\nodejs 一直next直到安装完成，期间的所有环境变量都会自动加入系统路径中（方便！） 配置settings.txt 如果你是免安装，有两种方法 我们打开免安装目录下的install.cmd文件，内容如下： 123456789101112131415@echo offset /P NVM_PATH=&quot;Enter the absolute path where the zip file is extracted/copied to: &quot; #输入nvm安装目录路径setx /M NVM_HOME &quot;%NVM_PATH%&quot; #将你输入的路径赋给NVM_HOME环境变量setx /M NVM_SYMLINK &quot;C:\\Program Files\\nodejs&quot; #默认路径赋给NVM_SYMLINK变量，可以将默认路径修改成任意路径setx /M PATH &quot;%PATH%;%NVM_HOME%;%NVM_SYMLINK%&quot; #将NVM_HOME、NVM_SYMLINK将入PATH中if exist &quot;%SYSTEMDRIVE%\\Program Files (x86)\\&quot; (set SYS_ARCH=64) else (set SYS_ARCH=32)(echo root: %NVM_HOME% &amp;&amp; echo path: %NVM_SYMLINK% &amp;&amp; echo arch: %SYS_ARCH% &amp;&amp; echo proxy: none) &gt; %NVM_HOME%\\settings.txt #在nvm目录下生成settings.txtnotepad %NVM_HOME%\\settings.txt@echo on 简单点说，install.cmd的作用就是帮你自动配置环境变量并生成settings.txt。 当然你也可以不用install.cmd，自己手动创建settings.txt，手动配置环境变量，毕竟自己动手，丰衣足食 如果你是GUI安装，直接打开nvm安装目录下的settings.txt ，修改如下： 123456root: D:\\Environment\\nvm //改成你的nvm安装目录path: D:\\Environment\\nodejs //改成你的nvm安装目录arch: 64 //你的系统指令架构64位，默认的不必修改proxy: none //代理配置，无node_mirror: http://npm.taobao.org/mirrors/node/ //node镜像源npm_mirror: https://npm.taobao.org/mirrors/npm/ //npm镜像源 配置环境变量 如果你是通过GUI安装的，那么你的环境变量已经自动配好了，你可以跳过这一步，也可以跟着看下去，看看自动配置是否有误 如果你是免安装又不想用install.cmd的话，建议在个人环境变量中加入下面的参数，因为这样不会扰乱系到统环境变量 ，快捷打开环境变量界面：windows+r =&gt; sysdm.cpl 12NVM_HOME： D:\\Environment\\nvm //改成你的nvm安装目录NVM_SYMLINK ： D:\\Environment\\nodejs //改成你的nodejs链接目录 最后别忘了，在PATH里加上 ;%NVM_HOME%;%NVM_SYMLINK%; 使用打开控制台，输入：nvm version,若是出现版本信息，则安装成功。若报错，那就面壁思过，我讲的辣么详细。 这里介绍一些常用命令，剩下自己探索吧 1234nvm install &lt;version&gt; [arch] ：version是版本号、arch是系统位数，默认64位，比如：nvm install 8.10.0 安装64位的nodejs8.10.0nvm uninstall &lt;version&gt; ：删除对应node版本nvm list ：会显示你系统中安装的所有node版本，并标明当前应用的那个node版本nvm use [version] [arch] ：选择生效哪个node版本 nrmnrm是什么及应用场景nrm（npm registry manager ），npm 镜像源管理工具。有时候访问国外资源太慢了，我们就得更换npm的源，命令是npm config set registry xxxxxxxx,考虑到有的公司还有私有源，如果每次更改源都要敲那么长的命令，那效率太低了。but nrm替我们管理了这些源，我们只需要简单的切换一下！ 安装及使用123456789101112131415npm install -g nrm 直接使用npm全局安装即可nrm --helpUsage: nrm [options] [command]Commands:ls 列出所有的源current 显示当前源的名称use &lt;registry&gt; 切换源add &lt;registry&gt; &lt;url&gt; [home] 添加源del|rm &lt;registry&gt; 删除原home &lt;registry&gt; [browser] 打开源的官方主页test [registry] 测试下这些源的响应时间help print this helpOptions:-h, --help output usage information-V, --version output the version number","categories":[{"name":"环境安装篇","slug":"环境安装篇","permalink":"https://cloudintheking.github.io/categories/环境安装篇/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://cloudintheking.github.io/tags/nodejs/"}]},{"title":"springboot多数据源配置","slug":"springboot多数据源配置","date":"2018-07-06T06:28:48.000Z","updated":"2021-04-26T13:07:09.988Z","comments":true,"path":"posts/84d9992c.html","link":"","permalink":"https://cloudintheking.github.io/posts/84d9992c.html","excerpt":"","text":"个人笔记，如有描述不当，欢迎留言指出~ 项目结构图 相关配置pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mymultidata&lt;/groupId&gt; &lt;artifactId&gt;ahuang&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;ahuang&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.12.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; application.properties12345678910111213141516171819202122232425#主数据源spring.datasource.primary.url=jdbc:mysql://localhost:3306/test1?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=truespring.datasource.primary.username=rootspring.datasource.primary.password=xxxxxxspring.datasource.primary.driver-class-name=com.mysql.jdbc.Driverspring.datasource.max-active=10spring.datasource.primary.max-idle=5spring.datasource.primary.min-idle=0#次数据源spring.datasource.secondary.url=jdbc:mysql://localhost:3306/test2?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=truespring.datasource.secondary.username=rootspring.datasource.secondary.password=xxxxxxspring.datasource.secondary.driver-class-name=com.mysql.jdbc.Driverspring.datasource.secondary.max-active=10spring.datasource.secondary.max-idle=5spring.datasource.secondary.min-idle=0#tomcatserver.port=8082#hibernate配置spring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialectspring.jpa.show-sql= true#mybatis配置mybatis.config-locations=classpath:mybatis/config.xmlmybatis.mapper-locations=classpath:mybatis/mapper/*/*/*.xml spring.datasource.primary.xxx、spring.datasource.secondary.xxx并非springboot的默认参数，这些配置并不能生效，所以要自己定义下数据源配置类。还记得config目录下DataSourceConfig.java这个类吗？这个类就是用来配置多个数据源的。 数据源配置DataSourceConfig.java123456789101112131415161718192021222324252627282930package com.mymultidata.ahuang.config;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;/** * @Author: hl * @Description: TODO * @Date: 13:55 2018/4/24 * @Modified By: * @Version 1.0 */@Configurationpublic class DataSourceConfig &#123; @Bean(\"primaryDataSource\") @Qualifier(\"primaryDataSource\") @ConfigurationProperties(prefix = \"spring.datasource.primary\") public DataSource primaryDataSource()&#123; return DataSourceBuilder.create().build(); &#125; @Bean(\"secondaryDataSource\") @Qualifier(\"secondaryDataSource\") @ConfigurationProperties(prefix = \"spring.datasource.secondary\") public DataSource secondaryDataSource()&#123; return DataSourceBuilder.create().build(); &#125;&#125; @ConfigurationProperties(prefix = &quot;spring.datasource.primary&quot;)：找到application.properties里前缀为spring.datasource.primary的参数并自动注入值到DataSource中。我这里是准备将primary数据源集成jpa，secondary数据源集成mybaitis,这里只配了两个数据源，同学们可以举一反三，third,fourth… 数据源事务配置基于jpaPrimaryConfig.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 package com.mymultidata.ahuang.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.persistence.EntityManager;import javax.sql.DataSource;import java.util.Map;/** * @Author: hl * @Description: TODO * @Date: 14:23 2018/4/24 * @Modified By: * @Version 1.0 */@Configuration@EnableTransactionManagement//entityManagerFactoryRef:引用实体管理工厂// transactionManagerRef:引用事务管理工厂// basePackages:设置jpa的repository接口类的包路径,可配置多个@EnableJpaRepositories( entityManagerFactoryRef = \"entityManagerFactoryPrimary\", transactionManagerRef = \"transactionManagerPrimary\", basePackages = &#123;\"com.mymultidata.ahuang.repository.jpa.jpa1\"&#125;)public class PrimaryConfig &#123; @Autowired @Qualifier(\"primaryDataSource\") private DataSource primaryDataSource;//注入primary数据源 @Autowired(required = false) private JpaProperties jpaProperties;//注入jpa全局参数 @Primary @Bean(name = \"entityManagerPrimary\") public EntityManager entityManager(EntityManagerFactoryBuilder builder)&#123; return entityManagerFactoryPrimary(builder).getObject().createEntityManager(); &#125; @Primary @Bean(name = \"entityManagerFactoryPrimary\") public LocalContainerEntityManagerFactoryBean entityManagerFactoryPrimary (EntityManagerFactoryBuilder builder) &#123; return builder .dataSource(primaryDataSource) .properties(getVendorProperties(primaryDataSource)) .packages(\"com.mymultidata.ahuang.domain.jpa.jpa1\") //设置实体类所在位置 .persistenceUnit(\"primaryPersistenceUnit\") .build(); &#125; private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) &#123; return jpaProperties.getHibernateProperties(dataSource); &#125; @Primary @Bean(name = \"transactionManagerPrimary\") public PlatformTransactionManager transactionManagerPrimary(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject()); &#125;&#125; 基于mybatisSecondaryConfig.java:1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.mymultidata.ahuang.config;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import javax.sql.DataSource;/** * @Author: hl * @Description: TODO * @Date: 15:05 2018/4/24 * @Modified By: * @Version 1.0 */@Configuration//basePackages:设置mapperj接口类所在位置@MapperScan(basePackages = &#123;\"com.mymultidata.ahuang.repository.mybatis.mapper1\"&#125;,sqlSessionTemplateRef =\"secondarySqlSessionTemplate\" )public class secondaryConfig &#123; @Autowired @Qualifier(\"secondaryDataSource\") private DataSource dataSource; @Bean(name = \"secondarySqlSessionFactory\") public SqlSessionFactory testSqlSessionFactory() throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mybatis/mapper/mapper1/*/*.xml\"));//设置mapper.xml路径,路径中之所以加了'*'号，是为了项目的功能划分,方便分析,如果你的映射文件不做功能划分的话，可以改为\"classpath:mybatis/mapper/mapper1/*.xml\" return bean.getObject(); &#125; @Bean(name = \"secondaryTransactionManager\") public DataSourceTransactionManager testTransactionManager(@Qualifier(\"secondaryDataSource\") DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; @Bean(name = \"secondarySqlSessionTemplate\") public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(\"secondarySqlSessionFactory\") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 到这里配置已经好了，剩下的就是结合业务去实现了。","categories":[{"name":"后端笔记","slug":"后端笔记","permalink":"https://cloudintheking.github.io/categories/后端笔记/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://cloudintheking.github.io/tags/springboot/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-04T13:53:56.000Z","updated":"2021-04-26T13:07:09.988Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://cloudintheking.github.io/posts/4a17b156.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://cloudintheking.github.io/tags/hexo/"}]}],"categories":[{"name":"后端笔记","slug":"后端笔记","permalink":"https://cloudintheking.github.io/categories/后端笔记/"},{"name":"问题总结篇","slug":"问题总结篇","permalink":"https://cloudintheking.github.io/categories/问题总结篇/"},{"name":"环境安装篇","slug":"环境安装篇","permalink":"https://cloudintheking.github.io/categories/环境安装篇/"},{"name":"算法篇","slug":"算法篇","permalink":"https://cloudintheking.github.io/categories/算法篇/"},{"name":"翻译篇","slug":"翻译篇","permalink":"https://cloudintheking.github.io/categories/翻译篇/"},{"name":"数据库","slug":"数据库","permalink":"https://cloudintheking.github.io/categories/数据库/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://cloudintheking.github.io/tags/spring/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://cloudintheking.github.io/tags/rabbitmq/"},{"name":"微服务","slug":"微服务","permalink":"https://cloudintheking.github.io/tags/微服务/"},{"name":"c++","slug":"c","permalink":"https://cloudintheking.github.io/tags/c/"},{"name":"数据结构","slug":"数据结构","permalink":"https://cloudintheking.github.io/tags/数据结构/"},{"name":"mongodb","slug":"mongodb","permalink":"https://cloudintheking.github.io/tags/mongodb/"},{"name":"sql","slug":"sql","permalink":"https://cloudintheking.github.io/tags/sql/"},{"name":"清单","slug":"清单","permalink":"https://cloudintheking.github.io/tags/清单/"},{"name":"flex-layout","slug":"flex-layout","permalink":"https://cloudintheking.github.io/tags/flex-layout/"},{"name":"nginx","slug":"nginx","permalink":"https://cloudintheking.github.io/tags/nginx/"},{"name":"powershell","slug":"powershell","permalink":"https://cloudintheking.github.io/tags/powershell/"},{"name":"python","slug":"python","permalink":"https://cloudintheking.github.io/tags/python/"},{"name":"nodejs","slug":"nodejs","permalink":"https://cloudintheking.github.io/tags/nodejs/"},{"name":"springboot","slug":"springboot","permalink":"https://cloudintheking.github.io/tags/springboot/"},{"name":"hexo","slug":"hexo","permalink":"https://cloudintheking.github.io/tags/hexo/"}]}